{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\SPIDER\\\\Downloads\\\\Project\\\\Demo GPT\\\\Demo 1\\\\src\\\\components\\\\Game3D.js\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect } from 'react';\nimport * as THREE from 'three';\nimport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\nimport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\nimport { OBJLoader } from 'three/addons/loaders/OBJLoader.js';\nimport { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';\nimport { RenderPass } from 'three/addons/postprocessing/RenderPass.js';\nimport { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';\nimport { SMAAPass } from 'three/addons/postprocessing/SMAAPass.js';\nimport { Sky } from 'three/addons/objects/Sky.js';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Game3D = ({\n  gameState\n}) => {\n  _s();\n  const canvasRef = useRef(null);\n  const sceneRef = useRef(null);\n  const droneRef = useRef(null);\n  const composerRef = useRef(null);\n  const modelsRef = useRef({});\n  const texturesRef = useRef({});\n\n  // Convert game coordinates to scene coordinates\n  const gameToScene = React.useCallback((x, y) => {\n    const size = Math.sqrt(gameState.land.length);\n    const offset = (size - 1) / 2;\n    return {\n      x: x - offset,\n      z: y - offset\n    };\n  }, [gameState.land.length]);\n\n  // Calculate camera position based on grid size\n  const calculateCameraPosition = () => {\n    const size = Math.sqrt(gameState.land.length);\n    const distance = 2 + size * 1.5; // Base distance that scales with grid size\n    const height = 3 + size * 1.2; // Base height that scales with grid size\n    return {\n      position: new THREE.Vector3(distance, height, distance),\n      target: new THREE.Vector3(0, 0, 0)\n    };\n  };\n\n  // Load textures\n  const loadTextures = async () => {\n    const textureLoader = new THREE.TextureLoader();\n    const loadTexture = url => new Promise((resolve, reject) => {\n      textureLoader.load(url, resolve, undefined, reject);\n    });\n    try {\n      texturesRef.current = {\n        grass: {\n          diffuse: await loadTexture('/textures/grass.jpg'),\n          normal: await loadTexture('/textures/grass_normal.jpg')\n        },\n        soil: {\n          diffuse: await loadTexture('/textures/plowed_soil.jpg'),\n          normal: await loadTexture('/textures/plowed_soil_normal.jpg')\n        },\n        farmland: {\n          diffuse: await loadTexture('/textures/farmland.jpg'),\n          normal: await loadTexture('/textures/farmland_normal.jpg')\n        },\n        wheat: {\n          diffuse: await loadTexture('/textures/wheat.jpg'),\n          normal: await loadTexture('/textures/wheat_normal.jpg')\n        },\n        corn: {\n          diffuse: await loadTexture('/textures/corn.jpg'),\n          normal: await loadTexture('/textures/corn_normal.jpg')\n        },\n        potato: {\n          diffuse: await loadTexture('/textures/potato.jpg'),\n          normal: await loadTexture('/textures/potato_normal.jpg')\n        }\n      };\n\n      // Configure texture properties\n      Object.values(texturesRef.current).forEach(textures => {\n        Object.values(textures).forEach(texture => {\n          texture.wrapS = texture.wrapT = THREE.RepeatWrapping;\n          texture.repeat.set(1, 1);\n        });\n      });\n    } catch (error) {\n      console.error('Error loading textures:', error);\n    }\n  };\n\n  // Load models\n  const loadModels = async () => {\n    const gltfLoader = new GLTFLoader();\n    const objLoader = new OBJLoader();\n    const loadGLTF = url => new Promise((resolve, reject) => {\n      gltfLoader.load(url, resolve, undefined, reject);\n    });\n    const loadOBJ = url => new Promise((resolve, reject) => {\n      objLoader.load(url, resolve, undefined, reject);\n    });\n    try {\n      // Load drone model\n      const droneModel = await loadGLTF('/models/drone.glb');\n      modelsRef.current.drone = droneModel.scene;\n\n      // Load crop models\n      modelsRef.current.wheat = await loadOBJ('/models/wheat.obj');\n      modelsRef.current.corn = await loadOBJ('/models/corn.obj');\n      modelsRef.current.potato = await loadOBJ('/models/potato.obj');\n\n      // Configure models\n      Object.values(modelsRef.current).forEach(model => {\n        model.traverse(child => {\n          if (child.isMesh) {\n            child.castShadow = true;\n            child.receiveShadow = true;\n          }\n        });\n      });\n    } catch (error) {\n      console.error('Error loading models:', error);\n    }\n  };\n\n  // Create environment map\n  const createEnvironmentMap = renderer => {\n    const pmremGenerator = new THREE.PMREMGenerator(renderer);\n    pmremGenerator.compileEquirectangularShader();\n    const sky = new Sky();\n    sky.scale.setScalar(450000);\n    const sun = new THREE.Vector3();\n    const uniforms = sky.material.uniforms;\n    uniforms['turbidity'].value = 10;\n    uniforms['rayleigh'].value = 3;\n    uniforms['mieCoefficient'].value = 0.005;\n    uniforms['mieDirectionalG'].value = 0.7;\n    const phi = THREE.MathUtils.degToRad(90 - 2);\n    const theta = THREE.MathUtils.degToRad(180);\n    sun.setFromSphericalCoords(1, phi, theta);\n    uniforms['sunPosition'].value.copy(sun);\n    const renderTarget = pmremGenerator.fromScene(sky);\n    pmremGenerator.dispose();\n    return renderTarget.texture;\n  };\n\n  // Create fallback drone model\n  const createFallbackDrone = () => {\n    const droneGroup = new THREE.Group();\n\n    // Drone body\n    const bodyGeometry = new THREE.BoxGeometry(0.4, 0.1, 0.4);\n    const bodyMaterial = new THREE.MeshStandardMaterial({\n      color: 0x3498db,\n      metalness: 0.8,\n      roughness: 0.2\n    });\n    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);\n    body.castShadow = true;\n    droneGroup.add(body);\n\n    // Drone arms\n    const armGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.3);\n    const armMaterial = new THREE.MeshStandardMaterial({\n      color: 0x2c3e50,\n      metalness: 0.5,\n      roughness: 0.5\n    });\n\n    // Create four arms\n    for (let i = 0; i < 4; i++) {\n      const arm = new THREE.Mesh(armGeometry, armMaterial);\n      arm.position.y = 0.05;\n      arm.rotation.z = Math.PI / 2;\n      arm.rotation.y = i * Math.PI / 2;\n      arm.position.x = Math.cos(arm.rotation.y) * 0.2;\n      arm.position.z = Math.sin(arm.rotation.y) * 0.2;\n      arm.castShadow = true;\n      droneGroup.add(arm);\n    }\n\n    // Propellers\n    const propGeometry = new THREE.BoxGeometry(0.05, 0.01, 0.3);\n    const propMaterial = new THREE.MeshStandardMaterial({\n      color: 0x95a5a6,\n      metalness: 0.3,\n      roughness: 0.7\n    });\n\n    // Create four propellers\n    for (let i = 0; i < 4; i++) {\n      const propeller = new THREE.Group();\n      const blade1 = new THREE.Mesh(propGeometry, propMaterial);\n      const blade2 = new THREE.Mesh(propGeometry, propMaterial);\n      blade2.rotation.y = Math.PI / 2;\n      propeller.add(blade1, blade2);\n      propeller.position.y = 0.1;\n      propeller.position.x = Math.cos(i * Math.PI / 2) * 0.2;\n      propeller.position.z = Math.sin(i * Math.PI / 2) * 0.2;\n      propeller.castShadow = true;\n      droneGroup.add(propeller);\n    }\n    return droneGroup;\n  };\n\n  // Animation states and durations\n  const ANIMATIONS = {\n    PLOW: {\n      duration: 1000,\n      heightOffset: 0.05\n    },\n    PLANT: {\n      duration: 1500,\n      heightOffset: 0.1\n    },\n    GROW: {\n      duration: 3000,\n      stages: 3\n    },\n    HARVEST: {\n      duration: 2000,\n      heightOffset: 0.15\n    }\n  };\n\n  // Create and update ground plane\n  const updateGround = () => {\n    var _texturesRef$current, _texturesRef$current$;\n    if (!sceneRef.current) return;\n\n    // Remove old ground\n    const oldGround = sceneRef.current.children.find(child => child.userData.isGround);\n    if (oldGround) {\n      sceneRef.current.remove(oldGround);\n      if (oldGround.geometry) oldGround.geometry.dispose();\n      if (oldGround.material) oldGround.material.dispose();\n    }\n\n    // Create new ground with dynamic size\n    const size = Math.sqrt(gameState.land.length);\n    const groundSize = Math.max(size * 1.5, 2); // At least 2 units, scales with grid\n    const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize);\n    const groundMaterial = new THREE.MeshStandardMaterial({\n      color: 0x90EE90,\n      // Default grass color\n      roughness: 0.8,\n      metalness: 0.2\n    });\n\n    // Apply texture if available\n    if ((_texturesRef$current = texturesRef.current) !== null && _texturesRef$current !== void 0 && (_texturesRef$current$ = _texturesRef$current.grass) !== null && _texturesRef$current$ !== void 0 && _texturesRef$current$.diffuse) {\n      groundMaterial.map = texturesRef.current.grass.diffuse.clone(); // Clone texture to avoid sharing\n      groundMaterial.map.repeat.set(size, size);\n      groundMaterial.map.wrapS = groundMaterial.map.wrapT = THREE.RepeatWrapping;\n      groundMaterial.needsUpdate = true;\n    }\n    const ground = new THREE.Mesh(groundGeometry, groundMaterial);\n    ground.rotation.x = -Math.PI / 2;\n    ground.position.y = 0;\n    ground.receiveShadow = true;\n    ground.userData.isGround = true;\n    sceneRef.current.add(ground);\n  };\n\n  // Create and update tiles with animations\n  const updateTiles = () => {\n    if (!sceneRef.current) return;\n\n    // Remove old tiles\n    const oldTiles = sceneRef.current.children.filter(child => child.userData.isTile || child.userData.isCrop);\n    oldTiles.forEach(tile => {\n      sceneRef.current.remove(tile);\n      if (tile.geometry) tile.geometry.dispose();\n      if (tile.material) {\n        if (Array.isArray(tile.material)) {\n          tile.material.forEach(m => m.dispose());\n        } else {\n          tile.material.dispose();\n        }\n      }\n    });\n\n    // Create new tiles based on gameState\n    const size = Math.sqrt(gameState.land.length);\n    const tileSize = 0.95;\n    const offset = (size - 1) / 2;\n    gameState.land.forEach((tile, index) => {\n      const x = Math.floor(index / size);\n      const z = index % size;\n      const position = new THREE.Vector3(x - offset, 0.01, z - offset);\n\n      // Create base tile\n      const geometry = new THREE.PlaneGeometry(tileSize, tileSize);\n      let material;\n      if (tile.isPlowed) {\n        var _texturesRef$current2, _texturesRef$current3, _texturesRef$current4, _texturesRef$current5;\n        material = new THREE.MeshStandardMaterial({\n          map: ((_texturesRef$current2 = texturesRef.current) === null || _texturesRef$current2 === void 0 ? void 0 : (_texturesRef$current3 = _texturesRef$current2.soil) === null || _texturesRef$current3 === void 0 ? void 0 : _texturesRef$current3.diffuse) || null,\n          normalMap: ((_texturesRef$current4 = texturesRef.current) === null || _texturesRef$current4 === void 0 ? void 0 : (_texturesRef$current5 = _texturesRef$current4.soil) === null || _texturesRef$current5 === void 0 ? void 0 : _texturesRef$current5.normal) || null,\n          roughness: 0.8,\n          metalness: 0.2\n        });\n      } else if (tile.hasCrop) {\n        var _texturesRef$current6, _texturesRef$current7, _texturesRef$current8, _texturesRef$current9;\n        material = new THREE.MeshStandardMaterial({\n          map: ((_texturesRef$current6 = texturesRef.current) === null || _texturesRef$current6 === void 0 ? void 0 : (_texturesRef$current7 = _texturesRef$current6.farmland) === null || _texturesRef$current7 === void 0 ? void 0 : _texturesRef$current7.diffuse) || null,\n          normalMap: ((_texturesRef$current8 = texturesRef.current) === null || _texturesRef$current8 === void 0 ? void 0 : (_texturesRef$current9 = _texturesRef$current8.farmland) === null || _texturesRef$current9 === void 0 ? void 0 : _texturesRef$current9.normal) || null,\n          roughness: 0.7,\n          metalness: 0.3\n        });\n      } else {\n        var _texturesRef$current10, _texturesRef$current11, _texturesRef$current12, _texturesRef$current13;\n        material = new THREE.MeshStandardMaterial({\n          map: ((_texturesRef$current10 = texturesRef.current) === null || _texturesRef$current10 === void 0 ? void 0 : (_texturesRef$current11 = _texturesRef$current10.grass) === null || _texturesRef$current11 === void 0 ? void 0 : _texturesRef$current11.diffuse) || null,\n          normalMap: ((_texturesRef$current12 = texturesRef.current) === null || _texturesRef$current12 === void 0 ? void 0 : (_texturesRef$current13 = _texturesRef$current12.grass) === null || _texturesRef$current13 === void 0 ? void 0 : _texturesRef$current13.normal) || null,\n          roughness: 0.9,\n          metalness: 0.1\n        });\n      }\n      const mesh = new THREE.Mesh(geometry, material);\n      mesh.rotation.x = -Math.PI / 2;\n      mesh.position.copy(position);\n      mesh.receiveShadow = true;\n      mesh.userData.isTile = true;\n      mesh.userData.tileIndex = index;\n      sceneRef.current.add(mesh);\n\n      // Add crop if exists\n      if (tile.hasCrop && tile.cropType) {\n        var _texturesRef$current14, _texturesRef$current15, _texturesRef$current16, _texturesRef$current17;\n        const cropGeometry = new THREE.PlaneGeometry(tileSize * 0.8, tileSize * 0.8);\n        const cropMaterial = new THREE.MeshStandardMaterial({\n          map: ((_texturesRef$current14 = texturesRef.current) === null || _texturesRef$current14 === void 0 ? void 0 : (_texturesRef$current15 = _texturesRef$current14[tile.cropType]) === null || _texturesRef$current15 === void 0 ? void 0 : _texturesRef$current15.diffuse) || null,\n          normalMap: ((_texturesRef$current16 = texturesRef.current) === null || _texturesRef$current16 === void 0 ? void 0 : (_texturesRef$current17 = _texturesRef$current16[tile.cropType]) === null || _texturesRef$current17 === void 0 ? void 0 : _texturesRef$current17.normal) || null,\n          transparent: true,\n          alphaTest: 0.5,\n          roughness: 0.8,\n          metalness: 0.2\n        });\n        const cropMesh = new THREE.Mesh(cropGeometry, cropMaterial);\n        cropMesh.rotation.x = -Math.PI / 2;\n\n        // Calculate growth height based on crop state\n        const growthProgress = tile.cropState === 'ready' ? 1 : tile.cropState === 'growing' ? 0.5 : 0.2;\n        cropMesh.position.set(position.x, position.y + 0.2 * growthProgress,\n        // Height based on growth\n        position.z);\n        cropMesh.userData.isCrop = true;\n        cropMesh.userData.tileIndex = index;\n        cropMesh.userData.cropType = tile.cropType;\n        cropMesh.userData.growthState = tile.cropState;\n        sceneRef.current.add(cropMesh);\n      }\n    });\n\n    // Update grid helper\n    const oldGrid = sceneRef.current.children.find(child => child instanceof THREE.GridHelper);\n    if (oldGrid) {\n      sceneRef.current.remove(oldGrid);\n      oldGrid.material.dispose();\n      oldGrid.geometry.dispose();\n    }\n    const gridHelper = new THREE.GridHelper(size, size, 0x000000, 0x000000);\n    gridHelper.position.y = 0.01;\n    gridHelper.material.opacity = 0.2;\n    gridHelper.material.transparent = true;\n    sceneRef.current.add(gridHelper);\n\n    // Update ground plane\n    updateGround();\n  };\n\n  // Add animation function for tile actions\n  const animateTileAction = (tileIndex, actionType) => {\n    if (!sceneRef.current) return;\n    const tile = sceneRef.current.children.find(child => (child.userData.isTile || child.userData.isCrop) && child.userData.tileIndex === tileIndex);\n    if (!tile) return;\n    const animation = ANIMATIONS[actionType];\n    const startTime = Date.now();\n    const startPosition = tile.position.clone();\n    const animate = () => {\n      const elapsed = Date.now() - startTime;\n      const progress = Math.min(elapsed / animation.duration, 1);\n\n      // Different animation behaviors based on action type\n      switch (actionType) {\n        case 'PLOW':\n          // Plow animation: tile rises and falls\n          tile.position.y = startPosition.y + Math.sin(progress * Math.PI) * animation.heightOffset;\n          break;\n        case 'PLANT':\n          // Plant animation: crop grows from ground\n          if (tile.userData.isCrop) {\n            tile.scale.y = progress;\n            tile.position.y = startPosition.y + progress * animation.heightOffset;\n          }\n          break;\n        case 'GROW':\n          // Growth animation: crop scales up\n          if (tile.userData.isCrop) {\n            const stage = Math.floor(progress * animation.stages);\n            const stageProgress = progress * animation.stages % 1;\n            tile.scale.set(1 + 0.1 * stage + 0.1 * stageProgress, 1 + 0.2 * stage + 0.2 * stageProgress, 1 + 0.1 * stage + 0.1 * stageProgress);\n          }\n          break;\n        case 'HARVEST':\n          // Harvest animation: crop rises and fades\n          if (tile.userData.isCrop) {\n            tile.position.y = startPosition.y + progress * animation.heightOffset;\n            if (tile.material) {\n              tile.material.opacity = 1 - progress;\n            }\n          }\n          break;\n      }\n      if (progress < 1) {\n        requestAnimationFrame(animate);\n      } else if (actionType === 'HARVEST') {\n        // Remove crop mesh after harvest animation\n        sceneRef.current.remove(tile);\n        if (tile.geometry) tile.geometry.dispose();\n        if (tile.material) tile.material.dispose();\n      }\n    };\n    animate();\n  };\n  useEffect(() => {\n    if (!canvasRef.current) return;\n\n    // Create scene\n    const scene = new THREE.Scene();\n    scene.background = new THREE.Color(0x87CEEB);\n    scene.fog = new THREE.FogExp2(0x87CEEB, 0.01);\n    sceneRef.current = scene;\n\n    // Create camera with initial position\n    const camera = new THREE.PerspectiveCamera(60, 1, 0.1, 1000);\n    const initialCamera = calculateCameraPosition();\n    camera.position.copy(initialCamera.position);\n    camera.lookAt(initialCamera.target);\n\n    // Create renderer with improved settings\n    const renderer = new THREE.WebGLRenderer({\n      canvas: canvasRef.current,\n      antialias: true,\n      powerPreference: \"high-performance\",\n      stencil: false\n    });\n    renderer.setSize(600, 600);\n    renderer.shadowMap.enabled = true;\n    renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n    renderer.outputColorSpace = THREE.SRGBColorSpace;\n    renderer.toneMapping = THREE.ACESFilmicToneMapping;\n    renderer.toneMappingExposure = 1.0;\n    renderer.setPixelRatio(window.devicePixelRatio);\n\n    // Create environment map\n    const envMap = createEnvironmentMap(renderer);\n    scene.environment = envMap;\n\n    // Add lights with improved settings\n    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);\n    scene.add(ambientLight);\n    const sunLight = new THREE.DirectionalLight(0xffffff, 2.0);\n    sunLight.position.set(10, 10, 5);\n    sunLight.castShadow = true;\n    sunLight.shadow.mapSize.width = 2048;\n    sunLight.shadow.mapSize.height = 2048;\n    sunLight.shadow.camera.near = 0.5;\n    sunLight.shadow.camera.far = 50;\n    sunLight.shadow.camera.left = -10;\n    sunLight.shadow.camera.right = 10;\n    sunLight.shadow.camera.top = 10;\n    sunLight.shadow.camera.bottom = -10;\n    sunLight.shadow.bias = -0.001;\n    scene.add(sunLight);\n\n    // Add subtle point lights for better ambiance\n    const pointLight1 = new THREE.PointLight(0xffd700, 0.5, 10);\n    pointLight1.position.set(2, 2, 2);\n    scene.add(pointLight1);\n    const pointLight2 = new THREE.PointLight(0x00ffff, 0.3, 10);\n    pointLight2.position.set(-2, 3, -2);\n    scene.add(pointLight2);\n\n    // Initial ground setup will be handled by updateTiles\n    updateTiles();\n\n    // Setup post-processing with improved settings\n    const composer = new EffectComposer(renderer);\n    composerRef.current = composer;\n    const renderPass = new RenderPass(scene, camera);\n    composer.addPass(renderPass);\n    const bloomPass = new UnrealBloomPass(new THREE.Vector2(600, 600), 0.5,\n    // strength\n    0.4,\n    // radius\n    0.85 // threshold\n    );\n    composer.addPass(bloomPass);\n    const smaaPass = new SMAAPass(600, 600);\n    composer.addPass(smaaPass);\n\n    // Add OrbitControls with dynamic limits\n    const controls = new OrbitControls(camera, renderer.domElement);\n    controls.enableDamping = true;\n    controls.dampingFactor = 0.05;\n    controls.screenSpacePanning = false;\n    controls.minDistance = 2;\n    controls.maxDistance = 20;\n    controls.maxPolarAngle = Math.PI / 2.1;\n    controls.minPolarAngle = Math.PI / 6;\n    controls.enableZoom = true;\n    controls.zoomSpeed = 0.5;\n    controls.rotateSpeed = 0.5;\n\n    // Set initial camera position\n    camera.position.copy(initialCamera.position);\n    controls.target.copy(initialCamera.target);\n    controls.update();\n\n    // Load assets with improved error handling\n    Promise.all([loadTextures(), loadModels()]).then(() => {\n      // Add drone to scene with improved fallback handling\n      if (modelsRef.current.drone) {\n        const drone = modelsRef.current.drone.clone();\n        drone.scale.set(0.5, 0.5, 0.5);\n        drone.traverse(child => {\n          if (child.isMesh) {\n            child.castShadow = true;\n            child.material.envMapIntensity = 1;\n          }\n        });\n        scene.add(drone);\n        droneRef.current = drone;\n      } else {\n        console.log('Using fallback drone model');\n        const fallbackDrone = createFallbackDrone();\n        scene.add(fallbackDrone);\n        droneRef.current = fallbackDrone;\n      }\n    }).catch(error => {\n      console.error('Error loading assets:', error);\n      const fallbackDrone = createFallbackDrone();\n      scene.add(fallbackDrone);\n      droneRef.current = fallbackDrone;\n    });\n\n    // Animation loop with improved timing\n    let lastTime = 0;\n    const animate = time => {\n      requestAnimationFrame(animate);\n      const delta = (time - lastTime) / 1000;\n      lastTime = time;\n\n      // Update drone hover animation\n      if (droneRef.current) {\n        const baseHeight = 0.5;\n        droneRef.current.position.y = baseHeight + Math.sin(time * 0.002) * 0.1;\n\n        // Rotate propellers if using fallback model\n        if (!modelsRef.current.drone) {\n          droneRef.current.children.forEach((child, index) => {\n            if (index > 4) {\n              // Skip body and arms\n              child.rotation.y += 15 * delta;\n            }\n          });\n        }\n      }\n\n      // Update controls and render\n      controls.update();\n      composer.render();\n    };\n    animate(0);\n\n    // Cleanup with improved resource disposal\n    return () => {\n      renderer.dispose();\n      composer.dispose();\n      controls.dispose();\n      envMap.dispose();\n      Object.values(texturesRef.current).forEach(textures => {\n        Object.values(textures).forEach(texture => texture.dispose());\n      });\n      scene.traverse(object => {\n        if (object.geometry) object.geometry.dispose();\n        if (object.material) {\n          if (Array.isArray(object.material)) {\n            object.material.forEach(material => material.dispose());\n          } else {\n            object.material.dispose();\n          }\n        }\n      });\n    };\n  }, []);\n\n  // Update drone position when gameState changes\n  useEffect(() => {\n    if (!droneRef.current || !gameState.dronePosition) return;\n    const targetPos = gameToScene(gameState.dronePosition.x, gameState.dronePosition.y);\n\n    // Smoothly animate to new position\n    const duration = 500; // 0.5 seconds\n    const startPosition = {\n      x: droneRef.current.position.x,\n      y: droneRef.current.position.y,\n      z: droneRef.current.position.z\n    };\n    const startTime = Date.now();\n    const animate = () => {\n      const elapsed = Date.now() - startTime;\n      const progress = Math.min(elapsed / duration, 1);\n\n      // Smooth easing\n      const t = progress < 0.5 ? 4 * progress * progress * progress : 1 - Math.pow(-2 * progress + 2, 3) / 2;\n\n      // Update drone position\n      droneRef.current.position.x = startPosition.x + (targetPos.x - startPosition.x) * t;\n      droneRef.current.position.z = startPosition.z + (targetPos.z - startPosition.z) * t;\n      droneRef.current.position.y = 0.5 + Math.sin(Date.now() * 0.002) * 0.1; // Keep hover animation\n\n      if (progress < 1) {\n        requestAnimationFrame(animate);\n      }\n    };\n    animate();\n  }, [gameState.dronePosition, gameState.land.length, gameToScene]);\n\n  // Update tiles when gameState changes\n  useEffect(() => {\n    updateTiles();\n  }, [gameState.land]);\n\n  // Add new effect to handle camera position updates when grid size changes\n  useEffect(() => {\n    if (!canvasRef.current) return;\n    const newCamera = calculateCameraPosition();\n\n    // Get the orbit controls instance\n    const canvas = canvasRef.current;\n    const controls = canvas.__controls;\n    if (controls) {\n      // Smoothly animate to new position\n      const duration = 1000; // 1 second\n      const startPosition = controls.object.position.clone();\n      const startTarget = controls.target.clone();\n      const startTime = Date.now();\n      const animate = () => {\n        const elapsed = Date.now() - startTime;\n        const progress = Math.min(elapsed / duration, 1);\n\n        // Smooth easing\n        const t = progress < 0.5 ? 4 * progress * progress * progress : 1 - Math.pow(-2 * progress + 2, 3) / 2;\n\n        // Update camera position\n        controls.object.position.lerpVectors(startPosition, newCamera.position, t);\n        controls.target.lerpVectors(startTarget, newCamera.target, t);\n        controls.update();\n        if (progress < 1) {\n          requestAnimationFrame(animate);\n        }\n      };\n      animate();\n    }\n  }, [gameState.land.length]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    style: {\n      width: '600px',\n      height: '600px',\n      backgroundColor: '#000000',\n      margin: '0 auto',\n      borderRadius: '8px',\n      overflow: 'hidden',\n      boxShadow: '0 4px 6px rgba(0, 0, 0, 0.1)'\n    },\n    children: /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      style: {\n        width: '100%',\n        height: '100%'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 732,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 723,\n    columnNumber: 5\n  }, this);\n};\n_s(Game3D, \"D1kHSS7XsGTneJI7fgVtSyDTYrA=\");\n_c = Game3D;\nexport default Game3D;\nvar _c;\n$RefreshReg$(_c, \"Game3D\");","map":{"version":3,"names":["React","useRef","useEffect","THREE","OrbitControls","GLTFLoader","OBJLoader","EffectComposer","RenderPass","UnrealBloomPass","SMAAPass","Sky","jsxDEV","_jsxDEV","Game3D","gameState","_s","canvasRef","sceneRef","droneRef","composerRef","modelsRef","texturesRef","gameToScene","useCallback","x","y","size","Math","sqrt","land","length","offset","z","calculateCameraPosition","distance","height","position","Vector3","target","loadTextures","textureLoader","TextureLoader","loadTexture","url","Promise","resolve","reject","load","undefined","current","grass","diffuse","normal","soil","farmland","wheat","corn","potato","Object","values","forEach","textures","texture","wrapS","wrapT","RepeatWrapping","repeat","set","error","console","loadModels","gltfLoader","objLoader","loadGLTF","loadOBJ","droneModel","drone","scene","model","traverse","child","isMesh","castShadow","receiveShadow","createEnvironmentMap","renderer","pmremGenerator","PMREMGenerator","compileEquirectangularShader","sky","scale","setScalar","sun","uniforms","material","value","phi","MathUtils","degToRad","theta","setFromSphericalCoords","copy","renderTarget","fromScene","dispose","createFallbackDrone","droneGroup","Group","bodyGeometry","BoxGeometry","bodyMaterial","MeshStandardMaterial","color","metalness","roughness","body","Mesh","add","armGeometry","CylinderGeometry","armMaterial","i","arm","rotation","PI","cos","sin","propGeometry","propMaterial","propeller","blade1","blade2","ANIMATIONS","PLOW","duration","heightOffset","PLANT","GROW","stages","HARVEST","updateGround","_texturesRef$current","_texturesRef$current$","oldGround","children","find","userData","isGround","remove","geometry","groundSize","max","groundGeometry","PlaneGeometry","groundMaterial","map","clone","needsUpdate","ground","updateTiles","oldTiles","filter","isTile","isCrop","tile","Array","isArray","m","tileSize","index","floor","isPlowed","_texturesRef$current2","_texturesRef$current3","_texturesRef$current4","_texturesRef$current5","normalMap","hasCrop","_texturesRef$current6","_texturesRef$current7","_texturesRef$current8","_texturesRef$current9","_texturesRef$current10","_texturesRef$current11","_texturesRef$current12","_texturesRef$current13","mesh","tileIndex","cropType","_texturesRef$current14","_texturesRef$current15","_texturesRef$current16","_texturesRef$current17","cropGeometry","cropMaterial","transparent","alphaTest","cropMesh","growthProgress","cropState","growthState","oldGrid","GridHelper","gridHelper","opacity","animateTileAction","actionType","animation","startTime","Date","now","startPosition","animate","elapsed","progress","min","stage","stageProgress","requestAnimationFrame","Scene","background","Color","fog","FogExp2","camera","PerspectiveCamera","initialCamera","lookAt","WebGLRenderer","canvas","antialias","powerPreference","stencil","setSize","shadowMap","enabled","type","PCFSoftShadowMap","outputColorSpace","SRGBColorSpace","toneMapping","ACESFilmicToneMapping","toneMappingExposure","setPixelRatio","window","devicePixelRatio","envMap","environment","ambientLight","AmbientLight","sunLight","DirectionalLight","shadow","mapSize","width","near","far","left","right","top","bottom","bias","pointLight1","PointLight","pointLight2","composer","renderPass","addPass","bloomPass","Vector2","smaaPass","controls","domElement","enableDamping","dampingFactor","screenSpacePanning","minDistance","maxDistance","maxPolarAngle","minPolarAngle","enableZoom","zoomSpeed","rotateSpeed","update","all","then","envMapIntensity","log","fallbackDrone","catch","lastTime","time","delta","baseHeight","render","object","dronePosition","targetPos","t","pow","newCamera","__controls","startTarget","lerpVectors","style","backgroundColor","margin","borderRadius","overflow","boxShadow","ref","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/SPIDER/Downloads/Project/Demo GPT/Demo 1/src/components/Game3D.js"],"sourcesContent":["import React, { useRef, useEffect } from 'react';\r\nimport * as THREE from 'three';\r\nimport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\r\nimport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\r\nimport { OBJLoader } from 'three/addons/loaders/OBJLoader.js';\r\nimport { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';\r\nimport { RenderPass } from 'three/addons/postprocessing/RenderPass.js';\r\nimport { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';\r\nimport { SMAAPass } from 'three/addons/postprocessing/SMAAPass.js';\r\nimport { Sky } from 'three/addons/objects/Sky.js';\r\n\r\nconst Game3D = ({ gameState }) => {\r\n  const canvasRef = useRef(null);\r\n  const sceneRef = useRef(null);\r\n  const droneRef = useRef(null);\r\n  const composerRef = useRef(null);\r\n  const modelsRef = useRef({});\r\n  const texturesRef = useRef({});\r\n\r\n  // Convert game coordinates to scene coordinates\r\n  const gameToScene = React.useCallback((x, y) => {\r\n    const size = Math.sqrt(gameState.land.length);\r\n    const offset = (size - 1) / 2;\r\n    return {\r\n      x: x - offset,\r\n      z: y - offset\r\n    };\r\n  }, [gameState.land.length]);\r\n\r\n  // Calculate camera position based on grid size\r\n  const calculateCameraPosition = () => {\r\n    const size = Math.sqrt(gameState.land.length);\r\n    const distance = 2 + size * 1.5; // Base distance that scales with grid size\r\n    const height = 3 + size * 1.2;   // Base height that scales with grid size\r\n    return {\r\n      position: new THREE.Vector3(distance, height, distance),\r\n      target: new THREE.Vector3(0, 0, 0)\r\n    };\r\n  };\r\n\r\n  // Load textures\r\n  const loadTextures = async () => {\r\n    const textureLoader = new THREE.TextureLoader();\r\n    const loadTexture = (url) => new Promise((resolve, reject) => {\r\n      textureLoader.load(url, resolve, undefined, reject);\r\n    });\r\n\r\n    try {\r\n      texturesRef.current = {\r\n        grass: {\r\n          diffuse: await loadTexture('/textures/grass.jpg'),\r\n          normal: await loadTexture('/textures/grass_normal.jpg')\r\n        },\r\n        soil: {\r\n          diffuse: await loadTexture('/textures/plowed_soil.jpg'),\r\n          normal: await loadTexture('/textures/plowed_soil_normal.jpg')\r\n        },\r\n        farmland: {\r\n          diffuse: await loadTexture('/textures/farmland.jpg'),\r\n          normal: await loadTexture('/textures/farmland_normal.jpg')\r\n        },\r\n        wheat: {\r\n          diffuse: await loadTexture('/textures/wheat.jpg'),\r\n          normal: await loadTexture('/textures/wheat_normal.jpg')\r\n        },\r\n        corn: {\r\n          diffuse: await loadTexture('/textures/corn.jpg'),\r\n          normal: await loadTexture('/textures/corn_normal.jpg')\r\n        },\r\n        potato: {\r\n          diffuse: await loadTexture('/textures/potato.jpg'),\r\n          normal: await loadTexture('/textures/potato_normal.jpg')\r\n        }\r\n      };\r\n\r\n      // Configure texture properties\r\n      Object.values(texturesRef.current).forEach(textures => {\r\n        Object.values(textures).forEach(texture => {\r\n          texture.wrapS = texture.wrapT = THREE.RepeatWrapping;\r\n          texture.repeat.set(1, 1);\r\n        });\r\n      });\r\n    } catch (error) {\r\n      console.error('Error loading textures:', error);\r\n    }\r\n  };\r\n\r\n  // Load models\r\n  const loadModels = async () => {\r\n    const gltfLoader = new GLTFLoader();\r\n    const objLoader = new OBJLoader();\r\n\r\n    const loadGLTF = (url) => new Promise((resolve, reject) => {\r\n      gltfLoader.load(url, resolve, undefined, reject);\r\n    });\r\n\r\n    const loadOBJ = (url) => new Promise((resolve, reject) => {\r\n      objLoader.load(url, resolve, undefined, reject);\r\n    });\r\n\r\n    try {\r\n      // Load drone model\r\n      const droneModel = await loadGLTF('/models/drone.glb');\r\n      modelsRef.current.drone = droneModel.scene;\r\n\r\n      // Load crop models\r\n      modelsRef.current.wheat = await loadOBJ('/models/wheat.obj');\r\n      modelsRef.current.corn = await loadOBJ('/models/corn.obj');\r\n      modelsRef.current.potato = await loadOBJ('/models/potato.obj');\r\n\r\n      // Configure models\r\n      Object.values(modelsRef.current).forEach(model => {\r\n        model.traverse(child => {\r\n          if (child.isMesh) {\r\n            child.castShadow = true;\r\n            child.receiveShadow = true;\r\n          }\r\n        });\r\n      });\r\n    } catch (error) {\r\n      console.error('Error loading models:', error);\r\n    }\r\n  };\r\n\r\n  // Create environment map\r\n  const createEnvironmentMap = (renderer) => {\r\n    const pmremGenerator = new THREE.PMREMGenerator(renderer);\r\n    pmremGenerator.compileEquirectangularShader();\r\n\r\n    const sky = new Sky();\r\n    sky.scale.setScalar(450000);\r\n    \r\n    const sun = new THREE.Vector3();\r\n    const uniforms = sky.material.uniforms;\r\n    uniforms['turbidity'].value = 10;\r\n    uniforms['rayleigh'].value = 3;\r\n    uniforms['mieCoefficient'].value = 0.005;\r\n    uniforms['mieDirectionalG'].value = 0.7;\r\n\r\n    const phi = THREE.MathUtils.degToRad(90 - 2);\r\n    const theta = THREE.MathUtils.degToRad(180);\r\n    sun.setFromSphericalCoords(1, phi, theta);\r\n    uniforms['sunPosition'].value.copy(sun);\r\n\r\n    const renderTarget = pmremGenerator.fromScene(sky);\r\n    pmremGenerator.dispose();\r\n\r\n    return renderTarget.texture;\r\n  };\r\n\r\n  // Create fallback drone model\r\n  const createFallbackDrone = () => {\r\n    const droneGroup = new THREE.Group();\r\n\r\n    // Drone body\r\n    const bodyGeometry = new THREE.BoxGeometry(0.4, 0.1, 0.4);\r\n    const bodyMaterial = new THREE.MeshStandardMaterial({\r\n      color: 0x3498db,\r\n      metalness: 0.8,\r\n      roughness: 0.2\r\n    });\r\n    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);\r\n    body.castShadow = true;\r\n    droneGroup.add(body);\r\n\r\n    // Drone arms\r\n    const armGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.3);\r\n    const armMaterial = new THREE.MeshStandardMaterial({\r\n      color: 0x2c3e50,\r\n      metalness: 0.5,\r\n      roughness: 0.5\r\n    });\r\n\r\n    // Create four arms\r\n    for (let i = 0; i < 4; i++) {\r\n      const arm = new THREE.Mesh(armGeometry, armMaterial);\r\n      arm.position.y = 0.05;\r\n      arm.rotation.z = Math.PI / 2;\r\n      arm.rotation.y = (i * Math.PI) / 2;\r\n      arm.position.x = Math.cos(arm.rotation.y) * 0.2;\r\n      arm.position.z = Math.sin(arm.rotation.y) * 0.2;\r\n      arm.castShadow = true;\r\n      droneGroup.add(arm);\r\n    }\r\n\r\n    // Propellers\r\n    const propGeometry = new THREE.BoxGeometry(0.05, 0.01, 0.3);\r\n    const propMaterial = new THREE.MeshStandardMaterial({\r\n      color: 0x95a5a6,\r\n      metalness: 0.3,\r\n      roughness: 0.7\r\n    });\r\n\r\n    // Create four propellers\r\n    for (let i = 0; i < 4; i++) {\r\n      const propeller = new THREE.Group();\r\n      \r\n      const blade1 = new THREE.Mesh(propGeometry, propMaterial);\r\n      const blade2 = new THREE.Mesh(propGeometry, propMaterial);\r\n      blade2.rotation.y = Math.PI / 2;\r\n      \r\n      propeller.add(blade1, blade2);\r\n      propeller.position.y = 0.1;\r\n      propeller.position.x = Math.cos(i * Math.PI / 2) * 0.2;\r\n      propeller.position.z = Math.sin(i * Math.PI / 2) * 0.2;\r\n      propeller.castShadow = true;\r\n      \r\n      droneGroup.add(propeller);\r\n    }\r\n\r\n    return droneGroup;\r\n  };\r\n\r\n  // Animation states and durations\r\n  const ANIMATIONS = {\r\n    PLOW: {\r\n      duration: 1000,\r\n      heightOffset: 0.05\r\n    },\r\n    PLANT: {\r\n      duration: 1500,\r\n      heightOffset: 0.1\r\n    },\r\n    GROW: {\r\n      duration: 3000,\r\n      stages: 3\r\n    },\r\n    HARVEST: {\r\n      duration: 2000,\r\n      heightOffset: 0.15\r\n    }\r\n  };\r\n\r\n  // Create and update ground plane\r\n  const updateGround = () => {\r\n    if (!sceneRef.current) return;\r\n\r\n    // Remove old ground\r\n    const oldGround = sceneRef.current.children.find(child => child.userData.isGround);\r\n    if (oldGround) {\r\n      sceneRef.current.remove(oldGround);\r\n      if (oldGround.geometry) oldGround.geometry.dispose();\r\n      if (oldGround.material) oldGround.material.dispose();\r\n    }\r\n\r\n    // Create new ground with dynamic size\r\n    const size = Math.sqrt(gameState.land.length);\r\n    const groundSize = Math.max(size * 1.5, 2); // At least 2 units, scales with grid\r\n    const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize);\r\n    const groundMaterial = new THREE.MeshStandardMaterial({\r\n      color: 0x90EE90, // Default grass color\r\n      roughness: 0.8,\r\n      metalness: 0.2\r\n    });\r\n\r\n    // Apply texture if available\r\n    if (texturesRef.current?.grass?.diffuse) {\r\n      groundMaterial.map = texturesRef.current.grass.diffuse.clone(); // Clone texture to avoid sharing\r\n      groundMaterial.map.repeat.set(size, size);\r\n      groundMaterial.map.wrapS = groundMaterial.map.wrapT = THREE.RepeatWrapping;\r\n      groundMaterial.needsUpdate = true;\r\n    }\r\n\r\n    const ground = new THREE.Mesh(groundGeometry, groundMaterial);\r\n    ground.rotation.x = -Math.PI / 2;\r\n    ground.position.y = 0;\r\n    ground.receiveShadow = true;\r\n    ground.userData.isGround = true;\r\n    sceneRef.current.add(ground);\r\n  };\r\n\r\n  // Create and update tiles with animations\r\n  const updateTiles = () => {\r\n    if (!sceneRef.current) return;\r\n\r\n    // Remove old tiles\r\n    const oldTiles = sceneRef.current.children.filter(child => child.userData.isTile || child.userData.isCrop);\r\n    oldTiles.forEach(tile => {\r\n      sceneRef.current.remove(tile);\r\n      if (tile.geometry) tile.geometry.dispose();\r\n      if (tile.material) {\r\n        if (Array.isArray(tile.material)) {\r\n          tile.material.forEach(m => m.dispose());\r\n        } else {\r\n          tile.material.dispose();\r\n        }\r\n      }\r\n    });\r\n\r\n    // Create new tiles based on gameState\r\n    const size = Math.sqrt(gameState.land.length);\r\n    const tileSize = 0.95;\r\n    const offset = (size - 1) / 2;\r\n\r\n    gameState.land.forEach((tile, index) => {\r\n      const x = Math.floor(index / size);\r\n      const z = index % size;\r\n      const position = new THREE.Vector3(x - offset, 0.01, z - offset);\r\n\r\n      // Create base tile\r\n      const geometry = new THREE.PlaneGeometry(tileSize, tileSize);\r\n      let material;\r\n\r\n      if (tile.isPlowed) {\r\n        material = new THREE.MeshStandardMaterial({\r\n          map: texturesRef.current?.soil?.diffuse || null,\r\n          normalMap: texturesRef.current?.soil?.normal || null,\r\n          roughness: 0.8,\r\n          metalness: 0.2\r\n        });\r\n      } else if (tile.hasCrop) {\r\n        material = new THREE.MeshStandardMaterial({\r\n          map: texturesRef.current?.farmland?.diffuse || null,\r\n          normalMap: texturesRef.current?.farmland?.normal || null,\r\n          roughness: 0.7,\r\n          metalness: 0.3\r\n        });\r\n      } else {\r\n        material = new THREE.MeshStandardMaterial({\r\n          map: texturesRef.current?.grass?.diffuse || null,\r\n          normalMap: texturesRef.current?.grass?.normal || null,\r\n          roughness: 0.9,\r\n          metalness: 0.1\r\n        });\r\n      }\r\n\r\n      const mesh = new THREE.Mesh(geometry, material);\r\n      mesh.rotation.x = -Math.PI / 2;\r\n      mesh.position.copy(position);\r\n      mesh.receiveShadow = true;\r\n      mesh.userData.isTile = true;\r\n      mesh.userData.tileIndex = index;\r\n      \r\n      sceneRef.current.add(mesh);\r\n\r\n      // Add crop if exists\r\n      if (tile.hasCrop && tile.cropType) {\r\n        const cropGeometry = new THREE.PlaneGeometry(tileSize * 0.8, tileSize * 0.8);\r\n        const cropMaterial = new THREE.MeshStandardMaterial({\r\n          map: texturesRef.current?.[tile.cropType]?.diffuse || null,\r\n          normalMap: texturesRef.current?.[tile.cropType]?.normal || null,\r\n          transparent: true,\r\n          alphaTest: 0.5,\r\n          roughness: 0.8,\r\n          metalness: 0.2\r\n        });\r\n\r\n        const cropMesh = new THREE.Mesh(cropGeometry, cropMaterial);\r\n        cropMesh.rotation.x = -Math.PI / 2;\r\n        \r\n        // Calculate growth height based on crop state\r\n        const growthProgress = tile.cropState === 'ready' ? 1 : \r\n                             tile.cropState === 'growing' ? 0.5 : 0.2;\r\n        \r\n        cropMesh.position.set(\r\n          position.x,\r\n          position.y + 0.2 * growthProgress, // Height based on growth\r\n          position.z\r\n        );\r\n        \r\n        cropMesh.userData.isCrop = true;\r\n        cropMesh.userData.tileIndex = index;\r\n        cropMesh.userData.cropType = tile.cropType;\r\n        cropMesh.userData.growthState = tile.cropState;\r\n        \r\n        sceneRef.current.add(cropMesh);\r\n      }\r\n    });\r\n\r\n    // Update grid helper\r\n    const oldGrid = sceneRef.current.children.find(child => child instanceof THREE.GridHelper);\r\n    if (oldGrid) {\r\n      sceneRef.current.remove(oldGrid);\r\n      oldGrid.material.dispose();\r\n      oldGrid.geometry.dispose();\r\n    }\r\n\r\n    const gridHelper = new THREE.GridHelper(size, size, 0x000000, 0x000000);\r\n    gridHelper.position.y = 0.01;\r\n    gridHelper.material.opacity = 0.2;\r\n    gridHelper.material.transparent = true;\r\n    sceneRef.current.add(gridHelper);\r\n\r\n    // Update ground plane\r\n    updateGround();\r\n  };\r\n\r\n  // Add animation function for tile actions\r\n  const animateTileAction = (tileIndex, actionType) => {\r\n    if (!sceneRef.current) return;\r\n\r\n    const tile = sceneRef.current.children.find(\r\n      child => (child.userData.isTile || child.userData.isCrop) && \r\n      child.userData.tileIndex === tileIndex\r\n    );\r\n\r\n    if (!tile) return;\r\n\r\n    const animation = ANIMATIONS[actionType];\r\n    const startTime = Date.now();\r\n    const startPosition = tile.position.clone();\r\n\r\n    const animate = () => {\r\n      const elapsed = Date.now() - startTime;\r\n      const progress = Math.min(elapsed / animation.duration, 1);\r\n      \r\n      // Different animation behaviors based on action type\r\n      switch (actionType) {\r\n        case 'PLOW':\r\n          // Plow animation: tile rises and falls\r\n          tile.position.y = startPosition.y + \r\n            Math.sin(progress * Math.PI) * animation.heightOffset;\r\n          break;\r\n        \r\n        case 'PLANT':\r\n          // Plant animation: crop grows from ground\r\n          if (tile.userData.isCrop) {\r\n            tile.scale.y = progress;\r\n            tile.position.y = startPosition.y + (progress * animation.heightOffset);\r\n          }\r\n          break;\r\n        \r\n        case 'GROW':\r\n          // Growth animation: crop scales up\r\n          if (tile.userData.isCrop) {\r\n            const stage = Math.floor(progress * animation.stages);\r\n            const stageProgress = (progress * animation.stages) % 1;\r\n            tile.scale.set(\r\n              1 + (0.1 * stage) + (0.1 * stageProgress),\r\n              1 + (0.2 * stage) + (0.2 * stageProgress),\r\n              1 + (0.1 * stage) + (0.1 * stageProgress)\r\n            );\r\n          }\r\n          break;\r\n        \r\n        case 'HARVEST':\r\n          // Harvest animation: crop rises and fades\r\n          if (tile.userData.isCrop) {\r\n            tile.position.y = startPosition.y + (progress * animation.heightOffset);\r\n            if (tile.material) {\r\n              tile.material.opacity = 1 - progress;\r\n            }\r\n          }\r\n          break;\r\n      }\r\n\r\n      if (progress < 1) {\r\n        requestAnimationFrame(animate);\r\n      } else if (actionType === 'HARVEST') {\r\n        // Remove crop mesh after harvest animation\r\n        sceneRef.current.remove(tile);\r\n        if (tile.geometry) tile.geometry.dispose();\r\n        if (tile.material) tile.material.dispose();\r\n      }\r\n    };\r\n\r\n    animate();\r\n  };\r\n\r\n  useEffect(() => {\r\n    if (!canvasRef.current) return;\r\n\r\n    // Create scene\r\n    const scene = new THREE.Scene();\r\n    scene.background = new THREE.Color(0x87CEEB);\r\n    scene.fog = new THREE.FogExp2(0x87CEEB, 0.01);\r\n    sceneRef.current = scene;\r\n\r\n    // Create camera with initial position\r\n    const camera = new THREE.PerspectiveCamera(60, 1, 0.1, 1000);\r\n    const initialCamera = calculateCameraPosition();\r\n    camera.position.copy(initialCamera.position);\r\n    camera.lookAt(initialCamera.target);\r\n\r\n    // Create renderer with improved settings\r\n    const renderer = new THREE.WebGLRenderer({\r\n      canvas: canvasRef.current,\r\n      antialias: true,\r\n      powerPreference: \"high-performance\",\r\n      stencil: false\r\n    });\r\n    renderer.setSize(600, 600);\r\n    renderer.shadowMap.enabled = true;\r\n    renderer.shadowMap.type = THREE.PCFSoftShadowMap;\r\n    renderer.outputColorSpace = THREE.SRGBColorSpace;\r\n    renderer.toneMapping = THREE.ACESFilmicToneMapping;\r\n    renderer.toneMappingExposure = 1.0;\r\n    renderer.setPixelRatio(window.devicePixelRatio);\r\n\r\n    // Create environment map\r\n    const envMap = createEnvironmentMap(renderer);\r\n    scene.environment = envMap;\r\n\r\n    // Add lights with improved settings\r\n    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);\r\n    scene.add(ambientLight);\r\n\r\n    const sunLight = new THREE.DirectionalLight(0xffffff, 2.0);\r\n    sunLight.position.set(10, 10, 5);\r\n    sunLight.castShadow = true;\r\n    sunLight.shadow.mapSize.width = 2048;\r\n    sunLight.shadow.mapSize.height = 2048;\r\n    sunLight.shadow.camera.near = 0.5;\r\n    sunLight.shadow.camera.far = 50;\r\n    sunLight.shadow.camera.left = -10;\r\n    sunLight.shadow.camera.right = 10;\r\n    sunLight.shadow.camera.top = 10;\r\n    sunLight.shadow.camera.bottom = -10;\r\n    sunLight.shadow.bias = -0.001;\r\n    scene.add(sunLight);\r\n\r\n    // Add subtle point lights for better ambiance\r\n    const pointLight1 = new THREE.PointLight(0xffd700, 0.5, 10);\r\n    pointLight1.position.set(2, 2, 2);\r\n    scene.add(pointLight1);\r\n\r\n    const pointLight2 = new THREE.PointLight(0x00ffff, 0.3, 10);\r\n    pointLight2.position.set(-2, 3, -2);\r\n    scene.add(pointLight2);\r\n\r\n    // Initial ground setup will be handled by updateTiles\r\n    updateTiles();\r\n\r\n    // Setup post-processing with improved settings\r\n    const composer = new EffectComposer(renderer);\r\n    composerRef.current = composer;\r\n\r\n    const renderPass = new RenderPass(scene, camera);\r\n    composer.addPass(renderPass);\r\n\r\n    const bloomPass = new UnrealBloomPass(\r\n      new THREE.Vector2(600, 600),\r\n      0.5,  // strength\r\n      0.4,  // radius\r\n      0.85  // threshold\r\n    );\r\n    composer.addPass(bloomPass);\r\n\r\n    const smaaPass = new SMAAPass(600, 600);\r\n    composer.addPass(smaaPass);\r\n\r\n    // Add OrbitControls with dynamic limits\r\n    const controls = new OrbitControls(camera, renderer.domElement);\r\n    controls.enableDamping = true;\r\n    controls.dampingFactor = 0.05;\r\n    controls.screenSpacePanning = false;\r\n    controls.minDistance = 2;\r\n    controls.maxDistance = 20;\r\n    controls.maxPolarAngle = Math.PI / 2.1;\r\n    controls.minPolarAngle = Math.PI / 6;\r\n    controls.enableZoom = true;\r\n    controls.zoomSpeed = 0.5;\r\n    controls.rotateSpeed = 0.5;\r\n\r\n    // Set initial camera position\r\n    camera.position.copy(initialCamera.position);\r\n    controls.target.copy(initialCamera.target);\r\n    controls.update();\r\n\r\n    // Load assets with improved error handling\r\n    Promise.all([loadTextures(), loadModels()]).then(() => {\r\n      // Add drone to scene with improved fallback handling\r\n      if (modelsRef.current.drone) {\r\n        const drone = modelsRef.current.drone.clone();\r\n        drone.scale.set(0.5, 0.5, 0.5);\r\n        drone.traverse((child) => {\r\n          if (child.isMesh) {\r\n            child.castShadow = true;\r\n            child.material.envMapIntensity = 1;\r\n          }\r\n        });\r\n        scene.add(drone);\r\n        droneRef.current = drone;\r\n      } else {\r\n        console.log('Using fallback drone model');\r\n        const fallbackDrone = createFallbackDrone();\r\n        scene.add(fallbackDrone);\r\n        droneRef.current = fallbackDrone;\r\n      }\r\n    }).catch(error => {\r\n      console.error('Error loading assets:', error);\r\n      const fallbackDrone = createFallbackDrone();\r\n      scene.add(fallbackDrone);\r\n      droneRef.current = fallbackDrone;\r\n    });\r\n\r\n    // Animation loop with improved timing\r\n    let lastTime = 0;\r\n    const animate = (time) => {\r\n      requestAnimationFrame(animate);\r\n\r\n      const delta = (time - lastTime) / 1000;\r\n      lastTime = time;\r\n\r\n      // Update drone hover animation\r\n      if (droneRef.current) {\r\n        const baseHeight = 0.5;\r\n        droneRef.current.position.y = baseHeight + Math.sin(time * 0.002) * 0.1;\r\n        \r\n        // Rotate propellers if using fallback model\r\n        if (!modelsRef.current.drone) {\r\n          droneRef.current.children.forEach((child, index) => {\r\n            if (index > 4) { // Skip body and arms\r\n              child.rotation.y += 15 * delta;\r\n            }\r\n          });\r\n        }\r\n      }\r\n\r\n      // Update controls and render\r\n      controls.update();\r\n      composer.render();\r\n    };\r\n    animate(0);\r\n\r\n    // Cleanup with improved resource disposal\r\n    return () => {\r\n      renderer.dispose();\r\n      composer.dispose();\r\n      controls.dispose();\r\n      envMap.dispose();\r\n      \r\n      Object.values(texturesRef.current).forEach(textures => {\r\n        Object.values(textures).forEach(texture => texture.dispose());\r\n      });\r\n      \r\n      scene.traverse((object) => {\r\n        if (object.geometry) object.geometry.dispose();\r\n        if (object.material) {\r\n          if (Array.isArray(object.material)) {\r\n            object.material.forEach(material => material.dispose());\r\n          } else {\r\n            object.material.dispose();\r\n          }\r\n        }\r\n      });\r\n    };\r\n  }, []);\r\n\r\n  // Update drone position when gameState changes\r\n  useEffect(() => {\r\n    if (!droneRef.current || !gameState.dronePosition) return;\r\n    \r\n    const targetPos = gameToScene(gameState.dronePosition.x, gameState.dronePosition.y);\r\n    \r\n    // Smoothly animate to new position\r\n    const duration = 500; // 0.5 seconds\r\n    const startPosition = {\r\n      x: droneRef.current.position.x,\r\n      y: droneRef.current.position.y,\r\n      z: droneRef.current.position.z\r\n    };\r\n    const startTime = Date.now();\r\n\r\n    const animate = () => {\r\n      const elapsed = Date.now() - startTime;\r\n      const progress = Math.min(elapsed / duration, 1);\r\n      \r\n      // Smooth easing\r\n      const t = progress < 0.5 \r\n        ? 4 * progress * progress * progress \r\n        : 1 - Math.pow(-2 * progress + 2, 3) / 2;\r\n\r\n      // Update drone position\r\n      droneRef.current.position.x = startPosition.x + (targetPos.x - startPosition.x) * t;\r\n      droneRef.current.position.z = startPosition.z + (targetPos.z - startPosition.z) * t;\r\n      droneRef.current.position.y = 0.5 + Math.sin(Date.now() * 0.002) * 0.1; // Keep hover animation\r\n\r\n      if (progress < 1) {\r\n        requestAnimationFrame(animate);\r\n      }\r\n    };\r\n\r\n    animate();\r\n  }, [gameState.dronePosition, gameState.land.length, gameToScene]);\r\n\r\n  // Update tiles when gameState changes\r\n  useEffect(() => {\r\n    updateTiles();\r\n  }, [gameState.land]);\r\n\r\n  // Add new effect to handle camera position updates when grid size changes\r\n  useEffect(() => {\r\n    if (!canvasRef.current) return;\r\n    \r\n    const newCamera = calculateCameraPosition();\r\n    \r\n    // Get the orbit controls instance\r\n    const canvas = canvasRef.current;\r\n    const controls = canvas.__controls;\r\n    \r\n    if (controls) {\r\n      // Smoothly animate to new position\r\n      const duration = 1000; // 1 second\r\n      const startPosition = controls.object.position.clone();\r\n      const startTarget = controls.target.clone();\r\n      const startTime = Date.now();\r\n\r\n      const animate = () => {\r\n        const elapsed = Date.now() - startTime;\r\n        const progress = Math.min(elapsed / duration, 1);\r\n        \r\n        // Smooth easing\r\n        const t = progress < 0.5 \r\n          ? 4 * progress * progress * progress \r\n          : 1 - Math.pow(-2 * progress + 2, 3) / 2;\r\n\r\n        // Update camera position\r\n        controls.object.position.lerpVectors(startPosition, newCamera.position, t);\r\n        controls.target.lerpVectors(startTarget, newCamera.target, t);\r\n        controls.update();\r\n\r\n        if (progress < 1) {\r\n          requestAnimationFrame(animate);\r\n        }\r\n      };\r\n\r\n      animate();\r\n    }\r\n  }, [gameState.land.length]);\r\n\r\n  return (\r\n    <div style={{ \r\n      width: '600px', \r\n      height: '600px', \r\n      backgroundColor: '#000000',\r\n      margin: '0 auto',\r\n      borderRadius: '8px',\r\n      overflow: 'hidden',\r\n      boxShadow: '0 4px 6px rgba(0, 0, 0, 0.1)'\r\n    }}>\r\n      <canvas \r\n        ref={canvasRef}\r\n        style={{\r\n          width: '100%',\r\n          height: '100%'\r\n        }}\r\n      />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Game3D; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}