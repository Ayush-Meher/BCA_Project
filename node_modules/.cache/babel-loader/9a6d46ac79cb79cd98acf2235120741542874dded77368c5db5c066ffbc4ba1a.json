{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\SPIDER\\\\Downloads\\\\Project\\\\Demo GPT\\\\Demo 1\\\\src\\\\components\\\\Game3D.js\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect } from 'react';\nimport * as THREE from 'three';\nimport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\nimport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\nimport { OBJLoader } from 'three/addons/loaders/OBJLoader.js';\nimport { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';\nimport { RenderPass } from 'three/addons/postprocessing/RenderPass.js';\nimport { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';\nimport { SMAAPass } from 'three/addons/postprocessing/SMAAPass.js';\nimport { Sky } from 'three/addons/objects/Sky.js';\nimport { DataTexture } from 'three';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Game3D = ({\n  gameState,\n  onActionComplete,\n  lastAction = null // { type: 'PLOW'|'PLANT'|'GROW'|'HARVEST', tileIndex: number }\n}) => {\n  _s();\n  const canvasRef = useRef(null);\n  const sceneRef = useRef(null);\n  const droneRef = useRef(null);\n  const composerRef = useRef(null);\n  const modelsRef = useRef({});\n  const texturesRef = useRef({});\n  const actionQueueRef = useRef([]);\n\n  // Convert game coordinates to scene coordinates\n  const gameToScene = React.useCallback((x, y) => {\n    const size = Math.sqrt(gameState.land.length);\n    const offset = (size - 1) / 2;\n    return {\n      x: x - offset,\n      z: y - offset\n    };\n  }, [gameState.land.length]);\n\n  // Calculate camera position based on grid size\n  const calculateCameraPosition = () => {\n    const size = Math.sqrt(gameState.land.length);\n    const distance = 2 + size * 1.5; // Base distance that scales with grid size\n    const height = 3 + size * 1.2; // Base height that scales with grid size\n    return {\n      position: new THREE.Vector3(distance, height, distance),\n      target: new THREE.Vector3(0, 0, 0)\n    };\n  };\n\n  // Update the ANIMATIONS constant\n  const ANIMATIONS = {\n    PLOW: {\n      duration: 1500,\n      heightOffset: 0.2,\n      rotationOffset: Math.PI / 4\n    },\n    PLANT: {\n      duration: 2000,\n      heightOffset: 0.3,\n      scaleStart: 0.01\n    },\n    GROW: {\n      duration: 3000,\n      stages: 4,\n      heightMultiplier: 0.4\n    },\n    HARVEST: {\n      duration: 1500,\n      heightOffset: 0.5,\n      rotationOffset: Math.PI * 2\n    }\n  };\n\n  // Enhance the procedural texture generation\n  const generateProceduralTexture = (type, size = 512) => {\n    const data = new Uint8Array(size * size * 4);\n    const noiseData = new Uint8Array(size * size * 4);\n\n    // Generate Perlin-like noise\n    const generateNoise = () => {\n      for (let y = 0; y < size; y++) {\n        for (let x = 0; x < size; x++) {\n          const i = (y * size + x) * 4;\n          const value = Math.floor((Math.sin(x * 0.1) + Math.sin(y * 0.1) + Math.sin((x + y) * 0.05) + Math.sin(Math.sqrt(x * x + y * y) * 0.07)) * 32 + 128);\n          noiseData[i] = noiseData[i + 1] = noiseData[i + 2] = value;\n          noiseData[i + 3] = 255;\n        }\n      }\n    };\n    generateNoise();\n\n    // Create patterns\n    const createPattern = (baseColor, noiseIntensity = 0.3, pattern = null) => {\n      for (let i = 0; i < size * size; i++) {\n        const stride = i * 4;\n        const noise = (noiseData[stride] / 255 - 0.5) * noiseIntensity;\n        let r = baseColor.r + noise * 255;\n        let g = baseColor.g + noise * 255;\n        let b = baseColor.b + noise * 255;\n        if (pattern) {\n          const x = i % size;\n          const y = Math.floor(i / size);\n          const patternValue = pattern(x, y, size);\n          r = r * (1 - patternValue) + patternValue * baseColor.r;\n          g = g * (1 - patternValue) + patternValue * baseColor.g;\n          b = b * (1 - patternValue) + patternValue * baseColor.b;\n        }\n        data[stride] = Math.max(0, Math.min(255, r));\n        data[stride + 1] = Math.max(0, Math.min(255, g));\n        data[stride + 2] = Math.max(0, Math.min(255, b));\n        data[stride + 3] = 255;\n      }\n    };\n    const colors = {\n      grass: {\n        r: 124,\n        g: 179,\n        b: 66\n      },\n      soil: {\n        r: 121,\n        g: 85,\n        b: 61\n      },\n      farmland: {\n        r: 131,\n        g: 91,\n        b: 59\n      },\n      wheat: {\n        r: 243,\n        g: 218,\n        b: 109\n      },\n      corn: {\n        r: 251,\n        g: 192,\n        b: 45\n      },\n      potato: {\n        r: 141,\n        g: 110,\n        b: 99\n      }\n    };\n    const patterns = {\n      grass: (x, y) => {\n        const blade = Math.sin(x * 0.2) * Math.cos(y * 0.2) > 0.7;\n        return blade ? 0.2 : 0;\n      },\n      farmland: (x, y) => {\n        const row = Math.floor(y / (size / 16)) % 2;\n        const furrow = Math.sin(x * Math.PI * 8 / size) * 0.1;\n        return row ? 0.2 + furrow : 0;\n      },\n      soil: (x, y) => {\n        // Enhanced soil pattern with more visible plow lines\n        const gridSize = size / 8;\n        const localX = x % gridSize / gridSize;\n        const localY = y % gridSize / gridSize;\n\n        // Create plow lines\n        const plowLineX = Math.abs(Math.sin(localX * Math.PI)) * 0.3;\n        const plowLineY = Math.abs(Math.sin(localY * Math.PI)) * 0.3;\n        const plowPattern = Math.min(plowLineX, plowLineY);\n\n        // Add some randomness for soil texture\n        const noise = Math.sin(x * 0.3) * Math.cos(y * 0.3) * 0.1;\n        return plowPattern + noise;\n      }\n    };\n    switch (type) {\n      case 'grass':\n        {\n          createPattern(colors.grass, 0.3, patterns.grass);\n          break;\n        }\n      case 'soil':\n        {\n          createPattern(colors.soil, 0.4, patterns.soil);\n          break;\n        }\n      case 'farmland':\n        {\n          createPattern(colors.farmland, 0.3, patterns.farmland);\n          break;\n        }\n      case 'wheat':\n        {\n          createPattern(colors.wheat, 0.2);\n          break;\n        }\n      case 'corn':\n        {\n          createPattern(colors.corn, 0.25);\n          break;\n        }\n      case 'potato':\n        {\n          createPattern(colors.potato, 0.35);\n          break;\n        }\n      default:\n        {\n          createPattern(colors.grass, 0.3);\n          break;\n        }\n    }\n    const texture = new DataTexture(data, size, size, THREE.RGBAFormat);\n    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;\n    texture.needsUpdate = true;\n    return texture;\n  };\n\n  // Load textures\n  const loadTextures = async () => {\n    try {\n      texturesRef.current = {\n        grass: {\n          diffuse: generateProceduralTexture('grass'),\n          normal: generateProceduralTexture('grass')\n        },\n        soil: {\n          diffuse: generateProceduralTexture('soil'),\n          normal: generateProceduralTexture('soil')\n        },\n        farmland: {\n          diffuse: generateProceduralTexture('farmland'),\n          normal: generateProceduralTexture('farmland')\n        },\n        wheat: {\n          diffuse: generateProceduralTexture('wheat'),\n          normal: generateProceduralTexture('wheat')\n        },\n        corn: {\n          diffuse: generateProceduralTexture('corn'),\n          normal: generateProceduralTexture('corn')\n        },\n        potato: {\n          diffuse: generateProceduralTexture('potato'),\n          normal: generateProceduralTexture('potato')\n        }\n      };\n\n      // Configure texture properties\n      Object.values(texturesRef.current).forEach(textures => {\n        Object.values(textures).forEach(texture => {\n          texture.wrapS = texture.wrapT = THREE.RepeatWrapping;\n          texture.repeat.set(4, 4); // Increase repetition for more detail\n        });\n      });\n    } catch (error) {\n      console.error('Error generating textures:', error);\n    }\n  };\n\n  // Load models\n  const loadModels = async () => {\n    const gltfLoader = new GLTFLoader();\n    const objLoader = new OBJLoader();\n    const loadGLTF = url => new Promise((resolve, reject) => {\n      gltfLoader.load(url, resolve, undefined, reject);\n    });\n    const loadOBJ = url => new Promise((resolve, reject) => {\n      objLoader.load(url, resolve, undefined, reject);\n    });\n    try {\n      // Load drone model\n      const droneModel = await loadGLTF('/models/drone.glb');\n      modelsRef.current.drone = droneModel.scene;\n\n      // Load crop models\n      modelsRef.current.wheat = await loadOBJ('/models/wheat.obj');\n      modelsRef.current.corn = await loadOBJ('/models/corn.obj');\n      modelsRef.current.potato = await loadOBJ('/models/potato.obj');\n\n      // Configure models\n      Object.values(modelsRef.current).forEach(model => {\n        model.traverse(child => {\n          if (child.isMesh) {\n            child.castShadow = true;\n            child.receiveShadow = true;\n          }\n        });\n      });\n    } catch (error) {\n      console.error('Error loading models:', error);\n    }\n  };\n\n  // Create environment map\n  const createEnvironmentMap = renderer => {\n    const pmremGenerator = new THREE.PMREMGenerator(renderer);\n    pmremGenerator.compileEquirectangularShader();\n    const sky = new Sky();\n    sky.scale.setScalar(450000);\n    const sun = new THREE.Vector3();\n    const uniforms = sky.material.uniforms;\n    uniforms['turbidity'].value = 10;\n    uniforms['rayleigh'].value = 3;\n    uniforms['mieCoefficient'].value = 0.005;\n    uniforms['mieDirectionalG'].value = 0.7;\n    const phi = THREE.MathUtils.degToRad(90 - 2);\n    const theta = THREE.MathUtils.degToRad(180);\n    sun.setFromSphericalCoords(1, phi, theta);\n    uniforms['sunPosition'].value.copy(sun);\n    const renderTarget = pmremGenerator.fromScene(sky);\n    pmremGenerator.dispose();\n    return renderTarget.texture;\n  };\n\n  // Create fallback drone model\n  const createFallbackDrone = () => {\n    const droneGroup = new THREE.Group();\n\n    // Drone body - simpler, more stylized design\n    const bodyGeometry = new THREE.BoxGeometry(0.3, 0.1, 0.3);\n    const bodyMaterial = new THREE.MeshToonMaterial({\n      color: 0x4CAF50,\n      // Green color to match game theme\n      transparent: true,\n      opacity: 0.9\n    });\n    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);\n    body.castShadow = true;\n    droneGroup.add(body);\n\n    // Drone arms - thinner and more stylized\n    const armGeometry = new THREE.BoxGeometry(0.25, 0.02, 0.02);\n    const armMaterial = new THREE.MeshToonMaterial({\n      color: 0x81C784 // Lighter green\n    });\n\n    // Create four arms in a cross pattern\n    for (let i = 0; i < 4; i++) {\n      const arm = new THREE.Mesh(armGeometry, armMaterial);\n      arm.position.y = 0;\n      arm.rotation.y = i * Math.PI / 2;\n      arm.castShadow = true;\n      droneGroup.add(arm);\n    }\n\n    // Propellers - simpler design\n    const propGeometry = new THREE.BoxGeometry(0.08, 0.01, 0.08);\n    const propMaterial = new THREE.MeshToonMaterial({\n      color: 0xA5D6A7 // Even lighter green\n    });\n\n    // Create four propellers\n    for (let i = 0; i < 4; i++) {\n      const propeller = new THREE.Group();\n      const blade1 = new THREE.Mesh(propGeometry, propMaterial);\n      const blade2 = new THREE.Mesh(propGeometry, propMaterial);\n      blade2.rotation.y = Math.PI / 2;\n      propeller.add(blade1, blade2);\n      propeller.position.y = 0.05;\n      propeller.position.x = Math.cos(i * Math.PI / 2) * 0.15;\n      propeller.position.z = Math.sin(i * Math.PI / 2) * 0.15;\n      propeller.castShadow = true;\n      droneGroup.add(propeller);\n    }\n    return droneGroup;\n  };\n\n  // Create stylized crop models\n  const createStylizedCropModel = type => {\n    const group = new THREE.Group();\n    switch (type) {\n      case 'wheat':\n        {\n          // Create a stylized wheat stalk\n          const stalkGeometry = new THREE.CylinderGeometry(0.01, 0.01, 0.3, 4);\n          const stalkMaterial = new THREE.MeshToonMaterial({\n            color: 0x9CCC65\n          });\n          const stalk = new THREE.Mesh(stalkGeometry, stalkMaterial);\n          stalk.position.y = 0.15;\n\n          // Create wheat head\n          const headGeometry = new THREE.ConeGeometry(0.04, 0.15, 4);\n          const headMaterial = new THREE.MeshToonMaterial({\n            color: 0xFDD835\n          });\n          const head = new THREE.Mesh(headGeometry, headMaterial);\n          head.position.y = 0.35;\n          group.add(stalk, head);\n          break;\n        }\n      case 'corn':\n        {\n          // Create corn stalk\n          const stalkGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.4, 4);\n          const stalkMaterial = new THREE.MeshToonMaterial({\n            color: 0x7CB342\n          });\n          const stalk = new THREE.Mesh(stalkGeometry, stalkMaterial);\n          stalk.position.y = 0.2;\n\n          // Create corn cob\n          const cobGeometry = new THREE.CylinderGeometry(0.04, 0.04, 0.15, 6);\n          const cobMaterial = new THREE.MeshToonMaterial({\n            color: 0xFFEB3B\n          });\n          const cob = new THREE.Mesh(cobGeometry, cobMaterial);\n          cob.rotation.x = Math.PI / 2;\n          cob.position.y = 0.25;\n          cob.position.x = 0.06;\n          group.add(stalk, cob);\n          break;\n        }\n      case 'potato':\n        {\n          // Create potato plant\n          const leafGeometry = new THREE.BoxGeometry(0.15, 0.01, 0.15);\n          const leafMaterial = new THREE.MeshToonMaterial({\n            color: 0x558B2F\n          });\n\n          // Create multiple leaves\n          for (let i = 0; i < 3; i++) {\n            const leaf = new THREE.Mesh(leafGeometry, leafMaterial);\n            leaf.position.y = 0.05 + i * 0.05;\n            leaf.rotation.x = Math.random() * Math.PI / 4;\n            leaf.rotation.z = i * Math.PI * 2 / 3;\n            group.add(leaf);\n          }\n\n          // Create potato tuber\n          const tuberGeometry = new THREE.SphereGeometry(0.06, 6, 4);\n          const tuberMaterial = new THREE.MeshToonMaterial({\n            color: 0x8D6E63\n          });\n          const tuber = new THREE.Mesh(tuberGeometry, tuberMaterial);\n          tuber.position.y = 0.02;\n          tuber.scale.y = 0.7;\n          group.add(tuber);\n          break;\n        }\n      default:\n        break;\n    }\n    return group;\n  };\n\n  // Create and update ground plane\n  const updateGround = () => {\n    var _texturesRef$current, _texturesRef$current$;\n    if (!sceneRef.current) return;\n\n    // Remove old ground\n    const oldGround = sceneRef.current.children.find(child => child.userData.isGround);\n    if (oldGround) {\n      sceneRef.current.remove(oldGround);\n      if (oldGround.geometry) oldGround.geometry.dispose();\n      if (oldGround.material) oldGround.material.dispose();\n    }\n\n    // Create new ground with dynamic size\n    const size = Math.sqrt(gameState.land.length);\n    const groundSize = Math.max(size * 1.5, 2); // At least 2 units, scales with grid\n    const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize);\n    const groundMaterial = new THREE.MeshStandardMaterial({\n      color: 0x90EE90,\n      // Default grass color\n      roughness: 0.8,\n      metalness: 0.2\n    });\n\n    // Apply texture if available\n    if ((_texturesRef$current = texturesRef.current) !== null && _texturesRef$current !== void 0 && (_texturesRef$current$ = _texturesRef$current.grass) !== null && _texturesRef$current$ !== void 0 && _texturesRef$current$.diffuse) {\n      groundMaterial.map = texturesRef.current.grass.diffuse.clone(); // Clone texture to avoid sharing\n      groundMaterial.map.repeat.set(size, size);\n      groundMaterial.map.wrapS = groundMaterial.map.wrapT = THREE.RepeatWrapping;\n      groundMaterial.needsUpdate = true;\n    }\n    const ground = new THREE.Mesh(groundGeometry, groundMaterial);\n    ground.rotation.x = -Math.PI / 2;\n    ground.position.y = 0;\n    ground.receiveShadow = true;\n    ground.userData.isGround = true;\n    sceneRef.current.add(ground);\n  };\n\n  // Create and update tiles with animations\n  const updateTiles = () => {\n    if (!sceneRef.current) return;\n\n    // Remove old tiles\n    const oldTiles = sceneRef.current.children.filter(child => child.userData.isTile || child.userData.isCrop);\n    oldTiles.forEach(tile => {\n      sceneRef.current.remove(tile);\n      if (tile.geometry) tile.geometry.dispose();\n      if (tile.material) {\n        if (Array.isArray(tile.material)) {\n          tile.material.forEach(m => m.dispose());\n        } else {\n          tile.material.dispose();\n        }\n      }\n    });\n\n    // Create new tiles based on gameState\n    const size = Math.sqrt(gameState.land.length);\n    const tileSize = 0.95;\n    const offset = (size - 1) / 2;\n    gameState.land.forEach((tile, index) => {\n      const x = Math.floor(index / size);\n      const z = index % size;\n      const position = new THREE.Vector3(x - offset, 0.01, z - offset);\n\n      // Create base tile with toon material for more stylized look\n      const geometry = new THREE.PlaneGeometry(tileSize, tileSize);\n      let material;\n      if (tile.isPlowed) {\n        // Use basic material for plowed soil\n        material = new THREE.MeshStandardMaterial({\n          color: 0x795548,\n          // Brown color for plowed soil\n          roughness: 0.9,\n          metalness: 0.1,\n          side: THREE.DoubleSide\n        });\n\n        // Create simple texture for plowed soil\n        const plowedTexture = new THREE.TextureLoader().load(`data:image/png;base64,${btoa(String.fromCharCode(...generateProceduralTexture('soil').image.data))}`);\n        plowedTexture.wrapS = plowedTexture.wrapT = THREE.RepeatWrapping;\n        plowedTexture.repeat.set(2, 2);\n        material.map = plowedTexture;\n\n        // Add some ambient occlusion for depth\n        material.aoMapIntensity = 1.0;\n        material.aoMap = plowedTexture;\n      } else if (tile.hasCrop) {\n        var _texturesRef$current2, _texturesRef$current3;\n        material = new THREE.MeshStandardMaterial({\n          map: ((_texturesRef$current2 = texturesRef.current) === null || _texturesRef$current2 === void 0 ? void 0 : (_texturesRef$current3 = _texturesRef$current2.farmland) === null || _texturesRef$current3 === void 0 ? void 0 : _texturesRef$current3.diffuse) || null,\n          color: 0x8D6E63,\n          // Darker brown for farmland\n          roughness: 0.9,\n          metalness: 0.1,\n          side: THREE.DoubleSide\n        });\n      } else {\n        var _texturesRef$current4, _texturesRef$current5;\n        material = new THREE.MeshStandardMaterial({\n          map: ((_texturesRef$current4 = texturesRef.current) === null || _texturesRef$current4 === void 0 ? void 0 : (_texturesRef$current5 = _texturesRef$current4.grass) === null || _texturesRef$current5 === void 0 ? void 0 : _texturesRef$current5.diffuse) || null,\n          color: 0x81C784,\n          // Light green for grass\n          roughness: 0.9,\n          metalness: 0.1,\n          side: THREE.DoubleSide\n        });\n      }\n      const mesh = new THREE.Mesh(geometry, material);\n      mesh.rotation.x = -Math.PI / 2;\n      mesh.position.copy(position);\n      mesh.receiveShadow = true;\n      mesh.castShadow = true;\n      mesh.userData.isTile = true;\n      mesh.userData.tileIndex = index;\n      sceneRef.current.add(mesh);\n\n      // Add crop if exists using stylized models\n      if (tile.hasCrop && tile.cropType) {\n        const cropModel = createStylizedCropModel(tile.cropType);\n\n        // Calculate growth height based on crop state\n        const growthProgress = tile.cropState === 'ready' ? 1 : tile.cropState === 'growing' ? 0.5 : 0.2;\n        cropModel.scale.setScalar(growthProgress);\n        cropModel.position.set(position.x, position.y, position.z);\n        cropModel.userData.isCrop = true;\n        cropModel.userData.tileIndex = index;\n        cropModel.userData.cropType = tile.cropType;\n        cropModel.userData.growthState = tile.cropState;\n        sceneRef.current.add(cropModel);\n      }\n    });\n\n    // Update grid helper with more visible lines\n    const oldGrid = sceneRef.current.children.find(child => child instanceof THREE.GridHelper);\n    if (oldGrid) {\n      sceneRef.current.remove(oldGrid);\n      oldGrid.material.dispose();\n      oldGrid.geometry.dispose();\n    }\n    const gridHelper = new THREE.GridHelper(size, size, 0x000000, 0x000000);\n    gridHelper.position.y = 0.01;\n    gridHelper.material.opacity = 0.3;\n    gridHelper.material.transparent = true;\n    sceneRef.current.add(gridHelper);\n\n    // Update ground plane\n    updateGround();\n  };\n\n  // Update the animateTileAction function\n  const animateTileAction = (tileIndex, actionType) => {\n    if (!sceneRef.current) return;\n    const tile = sceneRef.current.children.find(child => (child.userData.isTile || child.userData.isCrop) && child.userData.tileIndex === tileIndex);\n    if (!tile) return;\n    const animation = ANIMATIONS[actionType];\n    const startTime = Date.now();\n    const startPosition = tile.position.clone();\n    const startRotation = tile.rotation.clone();\n    const animate = () => {\n      const elapsed = Date.now() - startTime;\n      const progress = Math.min(elapsed / animation.duration, 1);\n\n      // Smooth easing function\n      const easeInOutCubic = t => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;\n      const easeOutBack = t => {\n        const c1 = 1.70158;\n        const c3 = c1 + 1;\n        return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);\n      };\n      const t = easeInOutCubic(progress);\n      switch (actionType) {\n        case 'PLOW':\n          {\n            // Plow animation: rise, rotate, and fall with soil displacement effect\n            const verticalProgress = Math.sin(progress * Math.PI);\n            tile.position.y = startPosition.y + verticalProgress * animation.heightOffset;\n            tile.rotation.z = startRotation.z + progress * animation.rotationOffset;\n\n            // Add soil displacement effect\n            if (tile.material) {\n              const displacement = Math.sin(progress * Math.PI * 2) * 0.1;\n              tile.material.displacementScale = displacement;\n            }\n            break;\n          }\n        case 'PLANT':\n          {\n            // Plant animation: grow from ground with slight wobble\n            if (tile.userData.isCrop) {\n              const scale = animation.scaleStart + (1 - animation.scaleStart) * t;\n              const wobble = Math.sin(progress * Math.PI * 4) * (1 - progress) * 0.1;\n              tile.scale.set(scale, scale, scale);\n              tile.position.y = startPosition.y + animation.heightOffset * t;\n              tile.rotation.z = wobble;\n            }\n            break;\n          }\n        case 'GROW':\n          {\n            // Growth animation: smooth scale up with subtle movement\n            if (tile.userData.isCrop) {\n              const stage = Math.floor(progress * animation.stages);\n              const stageProgress = progress * animation.stages % 1;\n              const growthScale = 1 + (stage + easeOutBack(stageProgress)) * 0.25;\n              tile.scale.set(growthScale, growthScale, growthScale);\n              tile.position.y = startPosition.y + animation.heightMultiplier * growthScale * (1 + Math.sin(progress * Math.PI * 2) * 0.1);\n            }\n            break;\n          }\n        case 'HARVEST':\n          {\n            // Harvest animation: rise, spin, and fade\n            if (tile.userData.isCrop) {\n              const verticalProgress = easeOutBack(progress);\n              tile.position.y = startPosition.y + animation.heightOffset * verticalProgress;\n              tile.rotation.y = startRotation.y + animation.rotationOffset * progress;\n              tile.rotation.z = startRotation.z + Math.sin(progress * Math.PI * 4) * 0.2;\n              if (tile.material) {\n                tile.material.opacity = 1 - easeInOutCubic(progress);\n                tile.material.transparent = true;\n              }\n            }\n            break;\n          }\n      }\n      if (progress < 1) {\n        requestAnimationFrame(animate);\n      } else if (actionType === 'HARVEST') {\n        // Cleanup after harvest animation\n        sceneRef.current.remove(tile);\n        if (tile.geometry) tile.geometry.dispose();\n        if (tile.material) {\n          if (Array.isArray(tile.material)) {\n            tile.material.forEach(m => m.dispose());\n          } else {\n            tile.material.dispose();\n          }\n        }\n      }\n    };\n    animate();\n  };\n\n  // Handle incoming actions\n  useEffect(() => {\n    if (lastAction && lastAction.type && lastAction.tileIndex !== undefined) {\n      actionQueueRef.current.push(lastAction);\n\n      // Process the action\n      const processAction = async () => {\n        const action = actionQueueRef.current[0];\n        await new Promise(resolve => {\n          animateTileAction(action.tileIndex, action.type);\n\n          // Wait for animation to complete\n          const duration = ANIMATIONS[action.type].duration;\n          setTimeout(() => {\n            actionQueueRef.current.shift();\n            if (onActionComplete) {\n              onActionComplete(action);\n            }\n            resolve();\n          }, duration);\n        });\n\n        // Process next action if any\n        if (actionQueueRef.current.length > 0) {\n          processAction();\n        }\n      };\n      if (actionQueueRef.current.length === 1) {\n        processAction();\n      }\n    }\n  }, [lastAction]);\n  useEffect(() => {\n    if (!canvasRef.current) return;\n\n    // Create scene\n    const scene = new THREE.Scene();\n    scene.background = new THREE.Color(0x87CEEB);\n    scene.fog = new THREE.FogExp2(0x87CEEB, 0.01);\n    sceneRef.current = scene;\n\n    // Create camera with initial position\n    const camera = new THREE.PerspectiveCamera(60, 1, 0.1, 1000);\n    const initialCamera = calculateCameraPosition();\n    camera.position.copy(initialCamera.position);\n    camera.lookAt(initialCamera.target);\n\n    // Create renderer with improved settings\n    const renderer = new THREE.WebGLRenderer({\n      canvas: canvasRef.current,\n      antialias: true,\n      powerPreference: \"high-performance\",\n      stencil: false\n    });\n    renderer.setSize(600, 600);\n    renderer.shadowMap.enabled = true;\n    renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n    renderer.outputColorSpace = THREE.SRGBColorSpace;\n    renderer.toneMapping = THREE.ACESFilmicToneMapping;\n    renderer.toneMappingExposure = 1.0;\n    renderer.setPixelRatio(window.devicePixelRatio);\n\n    // Create environment map\n    const envMap = createEnvironmentMap(renderer);\n    scene.environment = envMap;\n\n    // Add lights with improved settings\n    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);\n    scene.add(ambientLight);\n    const sunLight = new THREE.DirectionalLight(0xffffff, 2.0);\n    sunLight.position.set(10, 10, 5);\n    sunLight.castShadow = true;\n    sunLight.shadow.mapSize.width = 2048;\n    sunLight.shadow.mapSize.height = 2048;\n    sunLight.shadow.camera.near = 0.5;\n    sunLight.shadow.camera.far = 50;\n    sunLight.shadow.camera.left = -10;\n    sunLight.shadow.camera.right = 10;\n    sunLight.shadow.camera.top = 10;\n    sunLight.shadow.camera.bottom = -10;\n    sunLight.shadow.bias = -0.001;\n    scene.add(sunLight);\n\n    // Add subtle point lights for better ambiance\n    const pointLight1 = new THREE.PointLight(0xffd700, 0.5, 10);\n    pointLight1.position.set(2, 2, 2);\n    scene.add(pointLight1);\n    const pointLight2 = new THREE.PointLight(0x00ffff, 0.3, 10);\n    pointLight2.position.set(-2, 3, -2);\n    scene.add(pointLight2);\n\n    // Initial ground setup will be handled by updateTiles\n    updateTiles();\n\n    // Setup post-processing with improved settings\n    const composer = new EffectComposer(renderer);\n    composerRef.current = composer;\n    const renderPass = new RenderPass(scene, camera);\n    composer.addPass(renderPass);\n    const bloomPass = new UnrealBloomPass(new THREE.Vector2(600, 600), 0.5,\n    // strength\n    0.4,\n    // radius\n    0.85 // threshold\n    );\n    composer.addPass(bloomPass);\n    const smaaPass = new SMAAPass(600, 600);\n    composer.addPass(smaaPass);\n\n    // Add OrbitControls with dynamic limits\n    const controls = new OrbitControls(camera, renderer.domElement);\n    controls.enableDamping = true;\n    controls.dampingFactor = 0.05;\n    controls.screenSpacePanning = false;\n    controls.minDistance = 2;\n    controls.maxDistance = 20;\n    controls.maxPolarAngle = Math.PI / 2.1;\n    controls.minPolarAngle = Math.PI / 6;\n    controls.enableZoom = true;\n    controls.zoomSpeed = 0.5;\n    controls.rotateSpeed = 0.5;\n\n    // Set initial camera position\n    camera.position.copy(initialCamera.position);\n    controls.target.copy(initialCamera.target);\n    controls.update();\n\n    // Load assets with improved error handling\n    Promise.all([loadTextures(), loadModels()]).then(() => {\n      // Add drone to scene with improved fallback handling\n      if (modelsRef.current.drone) {\n        const drone = modelsRef.current.drone.clone();\n        drone.scale.set(0.5, 0.5, 0.5);\n        drone.traverse(child => {\n          if (child.isMesh) {\n            child.castShadow = true;\n            child.material.envMapIntensity = 1;\n          }\n        });\n        scene.add(drone);\n        droneRef.current = drone;\n      } else {\n        console.log('Using fallback drone model');\n        const fallbackDrone = createFallbackDrone();\n        scene.add(fallbackDrone);\n        droneRef.current = fallbackDrone;\n      }\n    }).catch(error => {\n      console.error('Error loading assets:', error);\n      const fallbackDrone = createFallbackDrone();\n      scene.add(fallbackDrone);\n      droneRef.current = fallbackDrone;\n    });\n\n    // Animation loop with improved timing\n    let lastTime = 0;\n    const animate = time => {\n      requestAnimationFrame(animate);\n      const delta = (time - lastTime) / 1000;\n      lastTime = time;\n\n      // Update drone hover animation\n      if (droneRef.current) {\n        const baseHeight = 0.5;\n        droneRef.current.position.y = baseHeight + Math.sin(time * 0.002) * 0.1;\n\n        // Rotate propellers if using fallback model\n        if (!modelsRef.current.drone) {\n          droneRef.current.children.forEach((child, index) => {\n            if (index > 4) {\n              // Skip body and arms\n              child.rotation.y += 15 * delta;\n            }\n          });\n        }\n      }\n\n      // Update controls and render\n      controls.update();\n      composer.render();\n    };\n    animate(0);\n\n    // Cleanup with improved resource disposal\n    return () => {\n      renderer.dispose();\n      composer.dispose();\n      controls.dispose();\n      envMap.dispose();\n      Object.values(texturesRef.current).forEach(textures => {\n        Object.values(textures).forEach(texture => texture.dispose());\n      });\n      scene.traverse(object => {\n        if (object.geometry) object.geometry.dispose();\n        if (object.material) {\n          if (Array.isArray(object.material)) {\n            object.material.forEach(material => material.dispose());\n          } else {\n            object.material.dispose();\n          }\n        }\n      });\n    };\n  }, []);\n\n  // Update drone position when gameState changes\n  useEffect(() => {\n    if (!droneRef.current || !gameState.dronePosition) return;\n    const targetPos = gameToScene(gameState.dronePosition.x, gameState.dronePosition.y);\n\n    // Smoothly animate to new position\n    const duration = 500; // 0.5 seconds\n    const startPosition = {\n      x: droneRef.current.position.x,\n      y: droneRef.current.position.y,\n      z: droneRef.current.position.z\n    };\n    const startTime = Date.now();\n    const animate = () => {\n      const elapsed = Date.now() - startTime;\n      const progress = Math.min(elapsed / duration, 1);\n\n      // Smooth easing\n      const t = progress < 0.5 ? 4 * progress * progress * progress : 1 - Math.pow(-2 * progress + 2, 3) / 2;\n\n      // Update drone position\n      droneRef.current.position.x = startPosition.x + (targetPos.x - startPosition.x) * t;\n      droneRef.current.position.z = startPosition.z + (targetPos.z - startPosition.z) * t;\n      droneRef.current.position.y = 0.5 + Math.sin(Date.now() * 0.002) * 0.1; // Keep hover animation\n\n      if (progress < 1) {\n        requestAnimationFrame(animate);\n      }\n    };\n    animate();\n  }, [gameState.dronePosition, gameState.land.length, gameToScene]);\n\n  // Update tiles when gameState changes\n  useEffect(() => {\n    updateTiles();\n  }, [gameState.land]);\n\n  // Add new effect to handle camera position updates when grid size changes\n  useEffect(() => {\n    if (!canvasRef.current) return;\n    const newCamera = calculateCameraPosition();\n\n    // Get the orbit controls instance\n    const canvas = canvasRef.current;\n    const controls = canvas.__controls;\n    if (controls) {\n      // Smoothly animate to new position\n      const duration = 1000; // 1 second\n      const startPosition = controls.object.position.clone();\n      const startTarget = controls.target.clone();\n      const startTime = Date.now();\n      const animate = () => {\n        const elapsed = Date.now() - startTime;\n        const progress = Math.min(elapsed / duration, 1);\n\n        // Smooth easing\n        const t = progress < 0.5 ? 4 * progress * progress * progress : 1 - Math.pow(-2 * progress + 2, 3) / 2;\n\n        // Update camera position\n        controls.object.position.lerpVectors(startPosition, newCamera.position, t);\n        controls.target.lerpVectors(startTarget, newCamera.target, t);\n        controls.update();\n        if (progress < 1) {\n          requestAnimationFrame(animate);\n        }\n      };\n      animate();\n    }\n  }, [gameState.land.length]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    style: {\n      width: '600px',\n      height: '600px',\n      backgroundColor: '#000000',\n      margin: '0 auto',\n      borderRadius: '8px',\n      overflow: 'hidden',\n      boxShadow: '0 4px 6px rgba(0, 0, 0, 0.1)'\n    },\n    children: /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      style: {\n        width: '100%',\n        height: '100%'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 994,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 985,\n    columnNumber: 5\n  }, this);\n};\n_s(Game3D, \"pGZXR9akkM6qwt+/nwUgInwzgsA=\");\n_c = Game3D;\nexport default Game3D;\nvar _c;\n$RefreshReg$(_c, \"Game3D\");","map":{"version":3,"names":["React","useRef","useEffect","THREE","OrbitControls","GLTFLoader","OBJLoader","EffectComposer","RenderPass","UnrealBloomPass","SMAAPass","Sky","DataTexture","jsxDEV","_jsxDEV","Game3D","gameState","onActionComplete","lastAction","_s","canvasRef","sceneRef","droneRef","composerRef","modelsRef","texturesRef","actionQueueRef","gameToScene","useCallback","x","y","size","Math","sqrt","land","length","offset","z","calculateCameraPosition","distance","height","position","Vector3","target","ANIMATIONS","PLOW","duration","heightOffset","rotationOffset","PI","PLANT","scaleStart","GROW","stages","heightMultiplier","HARVEST","generateProceduralTexture","type","data","Uint8Array","noiseData","generateNoise","i","value","floor","sin","createPattern","baseColor","noiseIntensity","pattern","stride","noise","r","g","b","patternValue","max","min","colors","grass","soil","farmland","wheat","corn","potato","patterns","blade","cos","row","furrow","gridSize","localX","localY","plowLineX","abs","plowLineY","plowPattern","texture","RGBAFormat","wrapS","wrapT","RepeatWrapping","needsUpdate","loadTextures","current","diffuse","normal","Object","values","forEach","textures","repeat","set","error","console","loadModels","gltfLoader","objLoader","loadGLTF","url","Promise","resolve","reject","load","undefined","loadOBJ","droneModel","drone","scene","model","traverse","child","isMesh","castShadow","receiveShadow","createEnvironmentMap","renderer","pmremGenerator","PMREMGenerator","compileEquirectangularShader","sky","scale","setScalar","sun","uniforms","material","phi","MathUtils","degToRad","theta","setFromSphericalCoords","copy","renderTarget","fromScene","dispose","createFallbackDrone","droneGroup","Group","bodyGeometry","BoxGeometry","bodyMaterial","MeshToonMaterial","color","transparent","opacity","body","Mesh","add","armGeometry","armMaterial","arm","rotation","propGeometry","propMaterial","propeller","blade1","blade2","createStylizedCropModel","group","stalkGeometry","CylinderGeometry","stalkMaterial","stalk","headGeometry","ConeGeometry","headMaterial","head","cobGeometry","cobMaterial","cob","leafGeometry","leafMaterial","leaf","random","tuberGeometry","SphereGeometry","tuberMaterial","tuber","updateGround","_texturesRef$current","_texturesRef$current$","oldGround","children","find","userData","isGround","remove","geometry","groundSize","groundGeometry","PlaneGeometry","groundMaterial","MeshStandardMaterial","roughness","metalness","map","clone","ground","updateTiles","oldTiles","filter","isTile","isCrop","tile","Array","isArray","m","tileSize","index","isPlowed","side","DoubleSide","plowedTexture","TextureLoader","btoa","String","fromCharCode","image","aoMapIntensity","aoMap","hasCrop","_texturesRef$current2","_texturesRef$current3","_texturesRef$current4","_texturesRef$current5","mesh","tileIndex","cropType","cropModel","growthProgress","cropState","growthState","oldGrid","GridHelper","gridHelper","animateTileAction","actionType","animation","startTime","Date","now","startPosition","startRotation","animate","elapsed","progress","easeInOutCubic","t","pow","easeOutBack","c1","c3","verticalProgress","displacement","displacementScale","wobble","stage","stageProgress","growthScale","requestAnimationFrame","push","processAction","action","setTimeout","shift","Scene","background","Color","fog","FogExp2","camera","PerspectiveCamera","initialCamera","lookAt","WebGLRenderer","canvas","antialias","powerPreference","stencil","setSize","shadowMap","enabled","PCFSoftShadowMap","outputColorSpace","SRGBColorSpace","toneMapping","ACESFilmicToneMapping","toneMappingExposure","setPixelRatio","window","devicePixelRatio","envMap","environment","ambientLight","AmbientLight","sunLight","DirectionalLight","shadow","mapSize","width","near","far","left","right","top","bottom","bias","pointLight1","PointLight","pointLight2","composer","renderPass","addPass","bloomPass","Vector2","smaaPass","controls","domElement","enableDamping","dampingFactor","screenSpacePanning","minDistance","maxDistance","maxPolarAngle","minPolarAngle","enableZoom","zoomSpeed","rotateSpeed","update","all","then","envMapIntensity","log","fallbackDrone","catch","lastTime","time","delta","baseHeight","render","object","dronePosition","targetPos","newCamera","__controls","startTarget","lerpVectors","style","backgroundColor","margin","borderRadius","overflow","boxShadow","ref","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/SPIDER/Downloads/Project/Demo GPT/Demo 1/src/components/Game3D.js"],"sourcesContent":["import React, { useRef, useEffect } from 'react';\r\nimport * as THREE from 'three';\r\nimport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\r\nimport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\r\nimport { OBJLoader } from 'three/addons/loaders/OBJLoader.js';\r\nimport { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';\r\nimport { RenderPass } from 'three/addons/postprocessing/RenderPass.js';\r\nimport { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';\r\nimport { SMAAPass } from 'three/addons/postprocessing/SMAAPass.js';\r\nimport { Sky } from 'three/addons/objects/Sky.js';\r\nimport { DataTexture } from 'three';\r\n\r\nconst Game3D = ({ \r\n  gameState, \r\n  onActionComplete,\r\n  lastAction = null  // { type: 'PLOW'|'PLANT'|'GROW'|'HARVEST', tileIndex: number }\r\n}) => {\r\n  const canvasRef = useRef(null);\r\n  const sceneRef = useRef(null);\r\n  const droneRef = useRef(null);\r\n  const composerRef = useRef(null);\r\n  const modelsRef = useRef({});\r\n  const texturesRef = useRef({});\r\n  const actionQueueRef = useRef([]);\r\n\r\n  // Convert game coordinates to scene coordinates\r\n  const gameToScene = React.useCallback((x, y) => {\r\n    const size = Math.sqrt(gameState.land.length);\r\n    const offset = (size - 1) / 2;\r\n    return {\r\n      x: x - offset,\r\n      z: y - offset\r\n    };\r\n  }, [gameState.land.length]);\r\n\r\n  // Calculate camera position based on grid size\r\n  const calculateCameraPosition = () => {\r\n    const size = Math.sqrt(gameState.land.length);\r\n    const distance = 2 + size * 1.5; // Base distance that scales with grid size\r\n    const height = 3 + size * 1.2;   // Base height that scales with grid size\r\n    return {\r\n      position: new THREE.Vector3(distance, height, distance),\r\n      target: new THREE.Vector3(0, 0, 0)\r\n    };\r\n  };\r\n\r\n  // Update the ANIMATIONS constant\r\n  const ANIMATIONS = {\r\n    PLOW: {\r\n      duration: 1500,\r\n      heightOffset: 0.2,\r\n      rotationOffset: Math.PI / 4\r\n    },\r\n    PLANT: {\r\n      duration: 2000,\r\n      heightOffset: 0.3,\r\n      scaleStart: 0.01\r\n    },\r\n    GROW: {\r\n      duration: 3000,\r\n      stages: 4,\r\n      heightMultiplier: 0.4\r\n    },\r\n    HARVEST: {\r\n      duration: 1500,\r\n      heightOffset: 0.5,\r\n      rotationOffset: Math.PI * 2\r\n    }\r\n  };\r\n\r\n  // Enhance the procedural texture generation\r\n  const generateProceduralTexture = (type, size = 512) => {\r\n    const data = new Uint8Array(size * size * 4);\r\n    const noiseData = new Uint8Array(size * size * 4);\r\n    \r\n    // Generate Perlin-like noise\r\n    const generateNoise = () => {\r\n      for (let y = 0; y < size; y++) {\r\n        for (let x = 0; x < size; x++) {\r\n          const i = (y * size + x) * 4;\r\n          const value = Math.floor(\r\n            (Math.sin(x * 0.1) + Math.sin(y * 0.1) +\r\n             Math.sin((x + y) * 0.05) + Math.sin(Math.sqrt(x * x + y * y) * 0.07)) * 32 + 128\r\n          );\r\n          noiseData[i] = noiseData[i + 1] = noiseData[i + 2] = value;\r\n          noiseData[i + 3] = 255;\r\n        }\r\n      }\r\n    };\r\n\r\n    generateNoise();\r\n\r\n    // Create patterns\r\n    const createPattern = (baseColor, noiseIntensity = 0.3, pattern = null) => {\r\n      for (let i = 0; i < size * size; i++) {\r\n        const stride = i * 4;\r\n        const noise = (noiseData[stride] / 255 - 0.5) * noiseIntensity;\r\n\r\n        let r = baseColor.r + noise * 255;\r\n        let g = baseColor.g + noise * 255;\r\n        let b = baseColor.b + noise * 255;\r\n\r\n        if (pattern) {\r\n          const x = i % size;\r\n          const y = Math.floor(i / size);\r\n          const patternValue = pattern(x, y, size);\r\n          r = r * (1 - patternValue) + patternValue * baseColor.r;\r\n          g = g * (1 - patternValue) + patternValue * baseColor.g;\r\n          b = b * (1 - patternValue) + patternValue * baseColor.b;\r\n        }\r\n\r\n        data[stride] = Math.max(0, Math.min(255, r));\r\n        data[stride + 1] = Math.max(0, Math.min(255, g));\r\n        data[stride + 2] = Math.max(0, Math.min(255, b));\r\n        data[stride + 3] = 255;\r\n      }\r\n    };\r\n\r\n    const colors = {\r\n      grass: { r: 124, g: 179, b: 66 },\r\n      soil: { r: 121, g: 85, b: 61 },\r\n      farmland: { r: 131, g: 91, b: 59 },\r\n      wheat: { r: 243, g: 218, b: 109 },\r\n      corn: { r: 251, g: 192, b: 45 },\r\n      potato: { r: 141, g: 110, b: 99 }\r\n    };\r\n\r\n    const patterns = {\r\n      grass: (x, y) => {\r\n        const blade = Math.sin(x * 0.2) * Math.cos(y * 0.2) > 0.7;\r\n        return blade ? 0.2 : 0;\r\n      },\r\n      farmland: (x, y) => {\r\n        const row = Math.floor(y / (size / 16)) % 2;\r\n        const furrow = Math.sin(x * Math.PI * 8 / size) * 0.1;\r\n        return row ? 0.2 + furrow : 0;\r\n      },\r\n      soil: (x, y) => {\r\n        // Enhanced soil pattern with more visible plow lines\r\n        const gridSize = size / 8;\r\n        const localX = (x % gridSize) / gridSize;\r\n        const localY = (y % gridSize) / gridSize;\r\n        \r\n        // Create plow lines\r\n        const plowLineX = Math.abs(Math.sin(localX * Math.PI)) * 0.3;\r\n        const plowLineY = Math.abs(Math.sin(localY * Math.PI)) * 0.3;\r\n        const plowPattern = Math.min(plowLineX, plowLineY);\r\n        \r\n        // Add some randomness for soil texture\r\n        const noise = (Math.sin(x * 0.3) * Math.cos(y * 0.3)) * 0.1;\r\n        \r\n        return plowPattern + noise;\r\n      }\r\n    };\r\n\r\n    switch (type) {\r\n      case 'grass': {\r\n        createPattern(colors.grass, 0.3, patterns.grass);\r\n        break;\r\n      }\r\n      case 'soil': {\r\n        createPattern(colors.soil, 0.4, patterns.soil);\r\n        break;\r\n      }\r\n      case 'farmland': {\r\n        createPattern(colors.farmland, 0.3, patterns.farmland);\r\n        break;\r\n      }\r\n      case 'wheat': {\r\n        createPattern(colors.wheat, 0.2);\r\n        break;\r\n      }\r\n      case 'corn': {\r\n        createPattern(colors.corn, 0.25);\r\n        break;\r\n      }\r\n      case 'potato': {\r\n        createPattern(colors.potato, 0.35);\r\n        break;\r\n      }\r\n      default: {\r\n        createPattern(colors.grass, 0.3);\r\n        break;\r\n      }\r\n    }\r\n\r\n    const texture = new DataTexture(data, size, size, THREE.RGBAFormat);\r\n    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;\r\n    texture.needsUpdate = true;\r\n    return texture;\r\n  };\r\n\r\n  // Load textures\r\n  const loadTextures = async () => {\r\n    try {\r\n      texturesRef.current = {\r\n        grass: {\r\n          diffuse: generateProceduralTexture('grass'),\r\n          normal: generateProceduralTexture('grass')\r\n        },\r\n        soil: {\r\n          diffuse: generateProceduralTexture('soil'),\r\n          normal: generateProceduralTexture('soil')\r\n        },\r\n        farmland: {\r\n          diffuse: generateProceduralTexture('farmland'),\r\n          normal: generateProceduralTexture('farmland')\r\n        },\r\n        wheat: {\r\n          diffuse: generateProceduralTexture('wheat'),\r\n          normal: generateProceduralTexture('wheat')\r\n        },\r\n        corn: {\r\n          diffuse: generateProceduralTexture('corn'),\r\n          normal: generateProceduralTexture('corn')\r\n        },\r\n        potato: {\r\n          diffuse: generateProceduralTexture('potato'),\r\n          normal: generateProceduralTexture('potato')\r\n        }\r\n      };\r\n\r\n      // Configure texture properties\r\n      Object.values(texturesRef.current).forEach(textures => {\r\n        Object.values(textures).forEach(texture => {\r\n          texture.wrapS = texture.wrapT = THREE.RepeatWrapping;\r\n          texture.repeat.set(4, 4); // Increase repetition for more detail\r\n        });\r\n      });\r\n    } catch (error) {\r\n      console.error('Error generating textures:', error);\r\n    }\r\n  };\r\n\r\n  // Load models\r\n  const loadModels = async () => {\r\n    const gltfLoader = new GLTFLoader();\r\n    const objLoader = new OBJLoader();\r\n\r\n    const loadGLTF = (url) => new Promise((resolve, reject) => {\r\n      gltfLoader.load(url, resolve, undefined, reject);\r\n    });\r\n\r\n    const loadOBJ = (url) => new Promise((resolve, reject) => {\r\n      objLoader.load(url, resolve, undefined, reject);\r\n    });\r\n\r\n    try {\r\n      // Load drone model\r\n      const droneModel = await loadGLTF('/models/drone.glb');\r\n      modelsRef.current.drone = droneModel.scene;\r\n\r\n      // Load crop models\r\n      modelsRef.current.wheat = await loadOBJ('/models/wheat.obj');\r\n      modelsRef.current.corn = await loadOBJ('/models/corn.obj');\r\n      modelsRef.current.potato = await loadOBJ('/models/potato.obj');\r\n\r\n      // Configure models\r\n      Object.values(modelsRef.current).forEach(model => {\r\n        model.traverse(child => {\r\n          if (child.isMesh) {\r\n            child.castShadow = true;\r\n            child.receiveShadow = true;\r\n          }\r\n        });\r\n      });\r\n    } catch (error) {\r\n      console.error('Error loading models:', error);\r\n    }\r\n  };\r\n\r\n  // Create environment map\r\n  const createEnvironmentMap = (renderer) => {\r\n    const pmremGenerator = new THREE.PMREMGenerator(renderer);\r\n    pmremGenerator.compileEquirectangularShader();\r\n\r\n    const sky = new Sky();\r\n    sky.scale.setScalar(450000);\r\n    \r\n    const sun = new THREE.Vector3();\r\n    const uniforms = sky.material.uniforms;\r\n    uniforms['turbidity'].value = 10;\r\n    uniforms['rayleigh'].value = 3;\r\n    uniforms['mieCoefficient'].value = 0.005;\r\n    uniforms['mieDirectionalG'].value = 0.7;\r\n\r\n    const phi = THREE.MathUtils.degToRad(90 - 2);\r\n    const theta = THREE.MathUtils.degToRad(180);\r\n    sun.setFromSphericalCoords(1, phi, theta);\r\n    uniforms['sunPosition'].value.copy(sun);\r\n\r\n    const renderTarget = pmremGenerator.fromScene(sky);\r\n    pmremGenerator.dispose();\r\n\r\n    return renderTarget.texture;\r\n  };\r\n\r\n  // Create fallback drone model\r\n  const createFallbackDrone = () => {\r\n    const droneGroup = new THREE.Group();\r\n\r\n    // Drone body - simpler, more stylized design\r\n    const bodyGeometry = new THREE.BoxGeometry(0.3, 0.1, 0.3);\r\n    const bodyMaterial = new THREE.MeshToonMaterial({\r\n      color: 0x4CAF50,  // Green color to match game theme\r\n      transparent: true,\r\n      opacity: 0.9\r\n    });\r\n    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);\r\n    body.castShadow = true;\r\n    droneGroup.add(body);\r\n\r\n    // Drone arms - thinner and more stylized\r\n    const armGeometry = new THREE.BoxGeometry(0.25, 0.02, 0.02);\r\n    const armMaterial = new THREE.MeshToonMaterial({\r\n      color: 0x81C784  // Lighter green\r\n    });\r\n\r\n    // Create four arms in a cross pattern\r\n    for (let i = 0; i < 4; i++) {\r\n      const arm = new THREE.Mesh(armGeometry, armMaterial);\r\n      arm.position.y = 0;\r\n      arm.rotation.y = (i * Math.PI) / 2;\r\n      arm.castShadow = true;\r\n      droneGroup.add(arm);\r\n    }\r\n\r\n    // Propellers - simpler design\r\n    const propGeometry = new THREE.BoxGeometry(0.08, 0.01, 0.08);\r\n    const propMaterial = new THREE.MeshToonMaterial({\r\n      color: 0xA5D6A7  // Even lighter green\r\n    });\r\n\r\n    // Create four propellers\r\n    for (let i = 0; i < 4; i++) {\r\n      const propeller = new THREE.Group();\r\n      const blade1 = new THREE.Mesh(propGeometry, propMaterial);\r\n      const blade2 = new THREE.Mesh(propGeometry, propMaterial);\r\n      blade2.rotation.y = Math.PI / 2;\r\n      \r\n      propeller.add(blade1, blade2);\r\n      propeller.position.y = 0.05;\r\n      propeller.position.x = Math.cos(i * Math.PI / 2) * 0.15;\r\n      propeller.position.z = Math.sin(i * Math.PI / 2) * 0.15;\r\n      propeller.castShadow = true;\r\n      \r\n      droneGroup.add(propeller);\r\n    }\r\n\r\n    return droneGroup;\r\n  };\r\n\r\n  // Create stylized crop models\r\n  const createStylizedCropModel = (type) => {\r\n    const group = new THREE.Group();\r\n    \r\n    switch(type) {\r\n      case 'wheat': {\r\n        // Create a stylized wheat stalk\r\n        const stalkGeometry = new THREE.CylinderGeometry(0.01, 0.01, 0.3, 4);\r\n        const stalkMaterial = new THREE.MeshToonMaterial({ color: 0x9CCC65 });\r\n        const stalk = new THREE.Mesh(stalkGeometry, stalkMaterial);\r\n        stalk.position.y = 0.15;\r\n        \r\n        // Create wheat head\r\n        const headGeometry = new THREE.ConeGeometry(0.04, 0.15, 4);\r\n        const headMaterial = new THREE.MeshToonMaterial({ color: 0xFDD835 });\r\n        const head = new THREE.Mesh(headGeometry, headMaterial);\r\n        head.position.y = 0.35;\r\n        \r\n        group.add(stalk, head);\r\n        break;\r\n      }\r\n      case 'corn': {\r\n        // Create corn stalk\r\n        const stalkGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.4, 4);\r\n        const stalkMaterial = new THREE.MeshToonMaterial({ color: 0x7CB342 });\r\n        const stalk = new THREE.Mesh(stalkGeometry, stalkMaterial);\r\n        stalk.position.y = 0.2;\r\n        \r\n        // Create corn cob\r\n        const cobGeometry = new THREE.CylinderGeometry(0.04, 0.04, 0.15, 6);\r\n        const cobMaterial = new THREE.MeshToonMaterial({ color: 0xFFEB3B });\r\n        const cob = new THREE.Mesh(cobGeometry, cobMaterial);\r\n        cob.rotation.x = Math.PI / 2;\r\n        cob.position.y = 0.25;\r\n        cob.position.x = 0.06;\r\n        \r\n        group.add(stalk, cob);\r\n        break;\r\n      }\r\n      case 'potato': {\r\n        // Create potato plant\r\n        const leafGeometry = new THREE.BoxGeometry(0.15, 0.01, 0.15);\r\n        const leafMaterial = new THREE.MeshToonMaterial({ color: 0x558B2F });\r\n        \r\n        // Create multiple leaves\r\n        for (let i = 0; i < 3; i++) {\r\n          const leaf = new THREE.Mesh(leafGeometry, leafMaterial);\r\n          leaf.position.y = 0.05 + i * 0.05;\r\n          leaf.rotation.x = Math.random() * Math.PI / 4;\r\n          leaf.rotation.z = (i * Math.PI * 2) / 3;\r\n          group.add(leaf);\r\n        }\r\n        \r\n        // Create potato tuber\r\n        const tuberGeometry = new THREE.SphereGeometry(0.06, 6, 4);\r\n        const tuberMaterial = new THREE.MeshToonMaterial({ color: 0x8D6E63 });\r\n        const tuber = new THREE.Mesh(tuberGeometry, tuberMaterial);\r\n        tuber.position.y = 0.02;\r\n        tuber.scale.y = 0.7;\r\n        \r\n        group.add(tuber);\r\n        break;\r\n      }\r\n      default:\r\n        break;\r\n    }\r\n    \r\n    return group;\r\n  };\r\n\r\n  // Create and update ground plane\r\n  const updateGround = () => {\r\n    if (!sceneRef.current) return;\r\n\r\n    // Remove old ground\r\n    const oldGround = sceneRef.current.children.find(child => child.userData.isGround);\r\n    if (oldGround) {\r\n      sceneRef.current.remove(oldGround);\r\n      if (oldGround.geometry) oldGround.geometry.dispose();\r\n      if (oldGround.material) oldGround.material.dispose();\r\n    }\r\n\r\n    // Create new ground with dynamic size\r\n    const size = Math.sqrt(gameState.land.length);\r\n    const groundSize = Math.max(size * 1.5, 2); // At least 2 units, scales with grid\r\n    const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize);\r\n    const groundMaterial = new THREE.MeshStandardMaterial({\r\n      color: 0x90EE90, // Default grass color\r\n      roughness: 0.8,\r\n      metalness: 0.2\r\n    });\r\n\r\n    // Apply texture if available\r\n    if (texturesRef.current?.grass?.diffuse) {\r\n      groundMaterial.map = texturesRef.current.grass.diffuse.clone(); // Clone texture to avoid sharing\r\n      groundMaterial.map.repeat.set(size, size);\r\n      groundMaterial.map.wrapS = groundMaterial.map.wrapT = THREE.RepeatWrapping;\r\n      groundMaterial.needsUpdate = true;\r\n    }\r\n\r\n    const ground = new THREE.Mesh(groundGeometry, groundMaterial);\r\n    ground.rotation.x = -Math.PI / 2;\r\n    ground.position.y = 0;\r\n    ground.receiveShadow = true;\r\n    ground.userData.isGround = true;\r\n    sceneRef.current.add(ground);\r\n  };\r\n\r\n  // Create and update tiles with animations\r\n  const updateTiles = () => {\r\n    if (!sceneRef.current) return;\r\n\r\n    // Remove old tiles\r\n    const oldTiles = sceneRef.current.children.filter(child => child.userData.isTile || child.userData.isCrop);\r\n    oldTiles.forEach(tile => {\r\n      sceneRef.current.remove(tile);\r\n      if (tile.geometry) tile.geometry.dispose();\r\n      if (tile.material) {\r\n        if (Array.isArray(tile.material)) {\r\n          tile.material.forEach(m => m.dispose());\r\n        } else {\r\n          tile.material.dispose();\r\n        }\r\n      }\r\n    });\r\n\r\n    // Create new tiles based on gameState\r\n    const size = Math.sqrt(gameState.land.length);\r\n    const tileSize = 0.95;\r\n    const offset = (size - 1) / 2;\r\n\r\n    gameState.land.forEach((tile, index) => {\r\n      const x = Math.floor(index / size);\r\n      const z = index % size;\r\n      const position = new THREE.Vector3(x - offset, 0.01, z - offset);\r\n\r\n      // Create base tile with toon material for more stylized look\r\n      const geometry = new THREE.PlaneGeometry(tileSize, tileSize);\r\n      let material;\r\n\r\n      if (tile.isPlowed) {\r\n        // Use basic material for plowed soil\r\n        material = new THREE.MeshStandardMaterial({\r\n          color: 0x795548,  // Brown color for plowed soil\r\n          roughness: 0.9,\r\n          metalness: 0.1,\r\n          side: THREE.DoubleSide\r\n        });\r\n\r\n        // Create simple texture for plowed soil\r\n        const plowedTexture = new THREE.TextureLoader().load(\r\n          `data:image/png;base64,${btoa(String.fromCharCode(...generateProceduralTexture('soil').image.data))}`\r\n        );\r\n        plowedTexture.wrapS = plowedTexture.wrapT = THREE.RepeatWrapping;\r\n        plowedTexture.repeat.set(2, 2);\r\n        material.map = plowedTexture;\r\n\r\n        // Add some ambient occlusion for depth\r\n        material.aoMapIntensity = 1.0;\r\n        material.aoMap = plowedTexture;\r\n      } else if (tile.hasCrop) {\r\n        material = new THREE.MeshStandardMaterial({\r\n          map: texturesRef.current?.farmland?.diffuse || null,\r\n          color: 0x8D6E63,  // Darker brown for farmland\r\n          roughness: 0.9,\r\n          metalness: 0.1,\r\n          side: THREE.DoubleSide\r\n        });\r\n      } else {\r\n        material = new THREE.MeshStandardMaterial({\r\n          map: texturesRef.current?.grass?.diffuse || null,\r\n          color: 0x81C784,  // Light green for grass\r\n          roughness: 0.9,\r\n          metalness: 0.1,\r\n          side: THREE.DoubleSide\r\n        });\r\n      }\r\n\r\n      const mesh = new THREE.Mesh(geometry, material);\r\n      mesh.rotation.x = -Math.PI / 2;\r\n      mesh.position.copy(position);\r\n      mesh.receiveShadow = true;\r\n      mesh.castShadow = true;\r\n      mesh.userData.isTile = true;\r\n      mesh.userData.tileIndex = index;\r\n      \r\n      sceneRef.current.add(mesh);\r\n\r\n      // Add crop if exists using stylized models\r\n      if (tile.hasCrop && tile.cropType) {\r\n        const cropModel = createStylizedCropModel(tile.cropType);\r\n        \r\n        // Calculate growth height based on crop state\r\n        const growthProgress = tile.cropState === 'ready' ? 1 : \r\n                             tile.cropState === 'growing' ? 0.5 : 0.2;\r\n        \r\n        cropModel.scale.setScalar(growthProgress);\r\n        cropModel.position.set(\r\n          position.x,\r\n          position.y,\r\n          position.z\r\n        );\r\n        \r\n        cropModel.userData.isCrop = true;\r\n        cropModel.userData.tileIndex = index;\r\n        cropModel.userData.cropType = tile.cropType;\r\n        cropModel.userData.growthState = tile.cropState;\r\n        \r\n        sceneRef.current.add(cropModel);\r\n      }\r\n    });\r\n\r\n    // Update grid helper with more visible lines\r\n    const oldGrid = sceneRef.current.children.find(child => child instanceof THREE.GridHelper);\r\n    if (oldGrid) {\r\n      sceneRef.current.remove(oldGrid);\r\n      oldGrid.material.dispose();\r\n      oldGrid.geometry.dispose();\r\n    }\r\n\r\n    const gridHelper = new THREE.GridHelper(size, size, 0x000000, 0x000000);\r\n    gridHelper.position.y = 0.01;\r\n    gridHelper.material.opacity = 0.3;\r\n    gridHelper.material.transparent = true;\r\n    sceneRef.current.add(gridHelper);\r\n\r\n    // Update ground plane\r\n    updateGround();\r\n  };\r\n\r\n  // Update the animateTileAction function\r\n  const animateTileAction = (tileIndex, actionType) => {\r\n    if (!sceneRef.current) return;\r\n\r\n    const tile = sceneRef.current.children.find(\r\n      child => (child.userData.isTile || child.userData.isCrop) && \r\n      child.userData.tileIndex === tileIndex\r\n    );\r\n\r\n    if (!tile) return;\r\n\r\n    const animation = ANIMATIONS[actionType];\r\n    const startTime = Date.now();\r\n    const startPosition = tile.position.clone();\r\n    const startRotation = tile.rotation.clone();\r\n\r\n    const animate = () => {\r\n      const elapsed = Date.now() - startTime;\r\n      const progress = Math.min(elapsed / animation.duration, 1);\r\n      \r\n      // Smooth easing function\r\n      const easeInOutCubic = t => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;\r\n      const easeOutBack = t => {\r\n        const c1 = 1.70158;\r\n        const c3 = c1 + 1;\r\n        return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);\r\n      };\r\n      \r\n      const t = easeInOutCubic(progress);\r\n      \r\n      switch (actionType) {\r\n        case 'PLOW': {\r\n          // Plow animation: rise, rotate, and fall with soil displacement effect\r\n          const verticalProgress = Math.sin(progress * Math.PI);\r\n          tile.position.y = startPosition.y + verticalProgress * animation.heightOffset;\r\n          tile.rotation.z = startRotation.z + progress * animation.rotationOffset;\r\n          \r\n          // Add soil displacement effect\r\n          if (tile.material) {\r\n            const displacement = Math.sin(progress * Math.PI * 2) * 0.1;\r\n            tile.material.displacementScale = displacement;\r\n          }\r\n          break;\r\n        }\r\n        case 'PLANT': {\r\n          // Plant animation: grow from ground with slight wobble\r\n          if (tile.userData.isCrop) {\r\n            const scale = animation.scaleStart + (1 - animation.scaleStart) * t;\r\n            const wobble = Math.sin(progress * Math.PI * 4) * (1 - progress) * 0.1;\r\n            \r\n            tile.scale.set(scale, scale, scale);\r\n            tile.position.y = startPosition.y + animation.heightOffset * t;\r\n            tile.rotation.z = wobble;\r\n          }\r\n          break;\r\n        }\r\n        case 'GROW': {\r\n          // Growth animation: smooth scale up with subtle movement\r\n          if (tile.userData.isCrop) {\r\n            const stage = Math.floor(progress * animation.stages);\r\n            const stageProgress = (progress * animation.stages) % 1;\r\n            const growthScale = 1 + (stage + easeOutBack(stageProgress)) * 0.25;\r\n            \r\n            tile.scale.set(growthScale, growthScale, growthScale);\r\n            tile.position.y = startPosition.y + \r\n              animation.heightMultiplier * growthScale * (1 + Math.sin(progress * Math.PI * 2) * 0.1);\r\n          }\r\n          break;\r\n        }\r\n        case 'HARVEST': {\r\n          // Harvest animation: rise, spin, and fade\r\n          if (tile.userData.isCrop) {\r\n            const verticalProgress = easeOutBack(progress);\r\n            tile.position.y = startPosition.y + animation.heightOffset * verticalProgress;\r\n            tile.rotation.y = startRotation.y + animation.rotationOffset * progress;\r\n            tile.rotation.z = startRotation.z + Math.sin(progress * Math.PI * 4) * 0.2;\r\n            \r\n            if (tile.material) {\r\n              tile.material.opacity = 1 - easeInOutCubic(progress);\r\n              tile.material.transparent = true;\r\n            }\r\n          }\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (progress < 1) {\r\n        requestAnimationFrame(animate);\r\n      } else if (actionType === 'HARVEST') {\r\n        // Cleanup after harvest animation\r\n        sceneRef.current.remove(tile);\r\n        if (tile.geometry) tile.geometry.dispose();\r\n        if (tile.material) {\r\n          if (Array.isArray(tile.material)) {\r\n            tile.material.forEach(m => m.dispose());\r\n          } else {\r\n            tile.material.dispose();\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    animate();\r\n  };\r\n\r\n  // Handle incoming actions\r\n  useEffect(() => {\r\n    if (lastAction && lastAction.type && lastAction.tileIndex !== undefined) {\r\n      actionQueueRef.current.push(lastAction);\r\n      \r\n      // Process the action\r\n      const processAction = async () => {\r\n        const action = actionQueueRef.current[0];\r\n        await new Promise(resolve => {\r\n          animateTileAction(action.tileIndex, action.type);\r\n          \r\n          // Wait for animation to complete\r\n          const duration = ANIMATIONS[action.type].duration;\r\n          setTimeout(() => {\r\n            actionQueueRef.current.shift();\r\n            if (onActionComplete) {\r\n              onActionComplete(action);\r\n            }\r\n            resolve();\r\n          }, duration);\r\n        });\r\n\r\n        // Process next action if any\r\n        if (actionQueueRef.current.length > 0) {\r\n          processAction();\r\n        }\r\n      };\r\n\r\n      if (actionQueueRef.current.length === 1) {\r\n        processAction();\r\n      }\r\n    }\r\n  }, [lastAction]);\r\n\r\n  useEffect(() => {\r\n    if (!canvasRef.current) return;\r\n\r\n    // Create scene\r\n    const scene = new THREE.Scene();\r\n    scene.background = new THREE.Color(0x87CEEB);\r\n    scene.fog = new THREE.FogExp2(0x87CEEB, 0.01);\r\n    sceneRef.current = scene;\r\n\r\n    // Create camera with initial position\r\n    const camera = new THREE.PerspectiveCamera(60, 1, 0.1, 1000);\r\n    const initialCamera = calculateCameraPosition();\r\n    camera.position.copy(initialCamera.position);\r\n    camera.lookAt(initialCamera.target);\r\n\r\n    // Create renderer with improved settings\r\n    const renderer = new THREE.WebGLRenderer({\r\n      canvas: canvasRef.current,\r\n      antialias: true,\r\n      powerPreference: \"high-performance\",\r\n      stencil: false\r\n    });\r\n    renderer.setSize(600, 600);\r\n    renderer.shadowMap.enabled = true;\r\n    renderer.shadowMap.type = THREE.PCFSoftShadowMap;\r\n    renderer.outputColorSpace = THREE.SRGBColorSpace;\r\n    renderer.toneMapping = THREE.ACESFilmicToneMapping;\r\n    renderer.toneMappingExposure = 1.0;\r\n    renderer.setPixelRatio(window.devicePixelRatio);\r\n\r\n    // Create environment map\r\n    const envMap = createEnvironmentMap(renderer);\r\n    scene.environment = envMap;\r\n\r\n    // Add lights with improved settings\r\n    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);\r\n    scene.add(ambientLight);\r\n\r\n    const sunLight = new THREE.DirectionalLight(0xffffff, 2.0);\r\n    sunLight.position.set(10, 10, 5);\r\n    sunLight.castShadow = true;\r\n    sunLight.shadow.mapSize.width = 2048;\r\n    sunLight.shadow.mapSize.height = 2048;\r\n    sunLight.shadow.camera.near = 0.5;\r\n    sunLight.shadow.camera.far = 50;\r\n    sunLight.shadow.camera.left = -10;\r\n    sunLight.shadow.camera.right = 10;\r\n    sunLight.shadow.camera.top = 10;\r\n    sunLight.shadow.camera.bottom = -10;\r\n    sunLight.shadow.bias = -0.001;\r\n    scene.add(sunLight);\r\n\r\n    // Add subtle point lights for better ambiance\r\n    const pointLight1 = new THREE.PointLight(0xffd700, 0.5, 10);\r\n    pointLight1.position.set(2, 2, 2);\r\n    scene.add(pointLight1);\r\n\r\n    const pointLight2 = new THREE.PointLight(0x00ffff, 0.3, 10);\r\n    pointLight2.position.set(-2, 3, -2);\r\n    scene.add(pointLight2);\r\n\r\n    // Initial ground setup will be handled by updateTiles\r\n    updateTiles();\r\n\r\n    // Setup post-processing with improved settings\r\n    const composer = new EffectComposer(renderer);\r\n    composerRef.current = composer;\r\n\r\n    const renderPass = new RenderPass(scene, camera);\r\n    composer.addPass(renderPass);\r\n\r\n    const bloomPass = new UnrealBloomPass(\r\n      new THREE.Vector2(600, 600),\r\n      0.5,  // strength\r\n      0.4,  // radius\r\n      0.85  // threshold\r\n    );\r\n    composer.addPass(bloomPass);\r\n\r\n    const smaaPass = new SMAAPass(600, 600);\r\n    composer.addPass(smaaPass);\r\n\r\n    // Add OrbitControls with dynamic limits\r\n    const controls = new OrbitControls(camera, renderer.domElement);\r\n    controls.enableDamping = true;\r\n    controls.dampingFactor = 0.05;\r\n    controls.screenSpacePanning = false;\r\n    controls.minDistance = 2;\r\n    controls.maxDistance = 20;\r\n    controls.maxPolarAngle = Math.PI / 2.1;\r\n    controls.minPolarAngle = Math.PI / 6;\r\n    controls.enableZoom = true;\r\n    controls.zoomSpeed = 0.5;\r\n    controls.rotateSpeed = 0.5;\r\n\r\n    // Set initial camera position\r\n    camera.position.copy(initialCamera.position);\r\n    controls.target.copy(initialCamera.target);\r\n    controls.update();\r\n\r\n    // Load assets with improved error handling\r\n    Promise.all([loadTextures(), loadModels()]).then(() => {\r\n      // Add drone to scene with improved fallback handling\r\n      if (modelsRef.current.drone) {\r\n        const drone = modelsRef.current.drone.clone();\r\n        drone.scale.set(0.5, 0.5, 0.5);\r\n        drone.traverse((child) => {\r\n          if (child.isMesh) {\r\n            child.castShadow = true;\r\n            child.material.envMapIntensity = 1;\r\n          }\r\n        });\r\n        scene.add(drone);\r\n        droneRef.current = drone;\r\n      } else {\r\n        console.log('Using fallback drone model');\r\n        const fallbackDrone = createFallbackDrone();\r\n        scene.add(fallbackDrone);\r\n        droneRef.current = fallbackDrone;\r\n      }\r\n    }).catch(error => {\r\n      console.error('Error loading assets:', error);\r\n      const fallbackDrone = createFallbackDrone();\r\n      scene.add(fallbackDrone);\r\n      droneRef.current = fallbackDrone;\r\n    });\r\n\r\n    // Animation loop with improved timing\r\n    let lastTime = 0;\r\n    const animate = (time) => {\r\n      requestAnimationFrame(animate);\r\n\r\n      const delta = (time - lastTime) / 1000;\r\n      lastTime = time;\r\n\r\n      // Update drone hover animation\r\n      if (droneRef.current) {\r\n        const baseHeight = 0.5;\r\n        droneRef.current.position.y = baseHeight + Math.sin(time * 0.002) * 0.1;\r\n        \r\n        // Rotate propellers if using fallback model\r\n        if (!modelsRef.current.drone) {\r\n          droneRef.current.children.forEach((child, index) => {\r\n            if (index > 4) { // Skip body and arms\r\n              child.rotation.y += 15 * delta;\r\n            }\r\n          });\r\n        }\r\n      }\r\n\r\n      // Update controls and render\r\n      controls.update();\r\n      composer.render();\r\n    };\r\n    animate(0);\r\n\r\n    // Cleanup with improved resource disposal\r\n    return () => {\r\n      renderer.dispose();\r\n      composer.dispose();\r\n      controls.dispose();\r\n      envMap.dispose();\r\n      \r\n      Object.values(texturesRef.current).forEach(textures => {\r\n        Object.values(textures).forEach(texture => texture.dispose());\r\n      });\r\n      \r\n      scene.traverse((object) => {\r\n        if (object.geometry) object.geometry.dispose();\r\n        if (object.material) {\r\n          if (Array.isArray(object.material)) {\r\n            object.material.forEach(material => material.dispose());\r\n          } else {\r\n            object.material.dispose();\r\n          }\r\n        }\r\n      });\r\n    };\r\n  }, []);\r\n\r\n  // Update drone position when gameState changes\r\n  useEffect(() => {\r\n    if (!droneRef.current || !gameState.dronePosition) return;\r\n    \r\n    const targetPos = gameToScene(gameState.dronePosition.x, gameState.dronePosition.y);\r\n    \r\n    // Smoothly animate to new position\r\n    const duration = 500; // 0.5 seconds\r\n    const startPosition = {\r\n      x: droneRef.current.position.x,\r\n      y: droneRef.current.position.y,\r\n      z: droneRef.current.position.z\r\n    };\r\n    const startTime = Date.now();\r\n\r\n    const animate = () => {\r\n      const elapsed = Date.now() - startTime;\r\n      const progress = Math.min(elapsed / duration, 1);\r\n      \r\n      // Smooth easing\r\n      const t = progress < 0.5 \r\n        ? 4 * progress * progress * progress \r\n        : 1 - Math.pow(-2 * progress + 2, 3) / 2;\r\n\r\n      // Update drone position\r\n      droneRef.current.position.x = startPosition.x + (targetPos.x - startPosition.x) * t;\r\n      droneRef.current.position.z = startPosition.z + (targetPos.z - startPosition.z) * t;\r\n      droneRef.current.position.y = 0.5 + Math.sin(Date.now() * 0.002) * 0.1; // Keep hover animation\r\n\r\n      if (progress < 1) {\r\n        requestAnimationFrame(animate);\r\n      }\r\n    };\r\n\r\n    animate();\r\n  }, [gameState.dronePosition, gameState.land.length, gameToScene]);\r\n\r\n  // Update tiles when gameState changes\r\n  useEffect(() => {\r\n    updateTiles();\r\n  }, [gameState.land]);\r\n\r\n  // Add new effect to handle camera position updates when grid size changes\r\n  useEffect(() => {\r\n    if (!canvasRef.current) return;\r\n    \r\n    const newCamera = calculateCameraPosition();\r\n    \r\n    // Get the orbit controls instance\r\n    const canvas = canvasRef.current;\r\n    const controls = canvas.__controls;\r\n    \r\n    if (controls) {\r\n      // Smoothly animate to new position\r\n      const duration = 1000; // 1 second\r\n      const startPosition = controls.object.position.clone();\r\n      const startTarget = controls.target.clone();\r\n      const startTime = Date.now();\r\n\r\n      const animate = () => {\r\n        const elapsed = Date.now() - startTime;\r\n        const progress = Math.min(elapsed / duration, 1);\r\n        \r\n        // Smooth easing\r\n        const t = progress < 0.5 \r\n          ? 4 * progress * progress * progress \r\n          : 1 - Math.pow(-2 * progress + 2, 3) / 2;\r\n\r\n        // Update camera position\r\n        controls.object.position.lerpVectors(startPosition, newCamera.position, t);\r\n        controls.target.lerpVectors(startTarget, newCamera.target, t);\r\n        controls.update();\r\n\r\n        if (progress < 1) {\r\n          requestAnimationFrame(animate);\r\n        }\r\n      };\r\n\r\n      animate();\r\n    }\r\n  }, [gameState.land.length]);\r\n\r\n  return (\r\n    <div style={{ \r\n      width: '600px', \r\n      height: '600px', \r\n      backgroundColor: '#000000',\r\n      margin: '0 auto',\r\n      borderRadius: '8px',\r\n      overflow: 'hidden',\r\n      boxShadow: '0 4px 6px rgba(0, 0, 0, 0.1)'\r\n    }}>\r\n      <canvas \r\n        ref={canvasRef}\r\n        style={{\r\n          width: '100%',\r\n          height: '100%'\r\n        }}\r\n      />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Game3D; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}